import{_ as e,c as a,o,V as s}from"./chunks/framework.35c8bad0.js";const m=JSON.parse('{"title":"面试题[Vue生态系统]","description":"","frontmatter":{"title":"面试题[Vue生态系统]","date":"2023-09-17T00:00:00.000Z"},"headers":[],"relativePath":"blog/interview/230917.md","lastUpdated":1734789258000}'),t={name:"blog/interview/230917.md"},r=s(`<h1 id="面试题-vue生态系统" tabindex="-1">面试题[Vue生态系统] <a class="header-anchor" href="#面试题-vue生态系统" aria-label="Permalink to &quot;面试题[Vue生态系统]&quot;">​</a></h1><h2 id="_1-vuex" tabindex="-1">1. Vuex <a class="header-anchor" href="#_1-vuex" aria-label="Permalink to &quot;1. Vuex&quot;">​</a></h2><h3 id="_1-1-mapstate-引起的问题" tabindex="-1">1.1 mapstate 引起的问题 <a class="header-anchor" href="#_1-1-mapstate-引起的问题" aria-label="Permalink to &quot;1.1 mapstate 引起的问题&quot;">​</a></h3><ul><li>vuex 是单向数据流。</li><li>双向绑定的是 data 里面的属性，更改 state，不触发 data 属性的 set，也就不触发依赖更新；computed 里面每次更改值，会重新走一遍依赖收集更新机制，所以没问题。</li><li>computed 就是一个 lazy 的 watch。</li></ul><h2 id="_2-pinia" tabindex="-1">2. Pinia <a class="header-anchor" href="#_2-pinia" aria-label="Permalink to &quot;2. Pinia&quot;">​</a></h2><h3 id="_2-1-pinia-和-vuex-的区别" tabindex="-1">2.1 Pinia 和 Vuex 的区别 <a class="header-anchor" href="#_2-1-pinia-和-vuex-的区别" aria-label="Permalink to &quot;2.1 Pinia 和 Vuex 的区别&quot;">​</a></h3><p>Pinia 和 Vuex 是 Vue 中常用的状态管理工具，但它们有一些明显的区别：</p><ol><li><strong>API设计和使用方式</strong>： <ul><li>Pinia 提供了更加简洁和现代化的 API，使用起来更加符合开发者的直觉，而 Vuex 的 API 相对复杂，需要定义多种概念，比如 state、mutations、actions 等。</li><li>Vuex：：Vuex 的 API 设计是基于 Flux 模式，需要定义 state（状态）、mutations（同步修改状态的方法）、actions（异步操作）和 getters（类似于计算属性）；两者之间的通信需要通过 commit 和 dispatch。</li><li>Pinia：Pinia 则更加灵活，可以直接修改 state，并且 actions 既可以是同步的，也可以是异步的，更符合现代 JavaScript 开发习惯。Pinia 还利用了 Vue3 的组合式 API，使得代码结构更加简洁。</li></ul></li><li><strong>模块化和状态可拆分性</strong>： <ul><li>Vuex 需要手动分模块并合并，而 Pinia 支持更自然的模块化，通过定义和使用不同的 store 实现状态的拆分和复用。</li><li>Vuex：在 Vuex 中，模块划分需要手动编写，store 对象会变得庞大，需要手动引入各个模块并合并。</li><li>Pinia：Pinia 的模块化更加自然，每个 store 相当于是一个模块，可以单独定义并导入到组件中使用，这样的设计符合现代模块化开发的思想。</li></ul></li><li><strong>开发体验</strong>： <ul><li>Pinia 具有更好的 TypeScript 支持，能提供更好的开发体验，尤其是在类型推导和 IDE 提示方面，而 Vuex 虽然也支持 TypeScript，但需要更多的手动配置。</li><li><strong>TypeScript支持</strong>：Pinia 在设计之初就考虑了 TypeScript 的使用，类型推导非常自然；而 Vuex 支持 TypeScript 却需要更多的额外配置。</li><li><strong>调试工具</strong>：两者都支持 Vue DevTools，但由于 Pinia 遵循了 Vue 3 的新设计理念，所以在性能和调试效率上带来了优化。</li></ul></li><li><strong>插件生态</strong>：目前 Pinia 的插件生态还不如 Vuex 丰富。不过 Pinia 是 Vue 官方团队推荐的新一代状态管理工具，社区支持度和生态逐渐提升。</li></ol><h2 id="_3-vue-router" tabindex="-1">3. Vue Router <a class="header-anchor" href="#_3-vue-router" aria-label="Permalink to &quot;3. Vue Router&quot;">​</a></h2><h3 id="_3-1-hash-模式和-history-模式的区别" tabindex="-1">3.1 hash 模式和 history 模式的区别 <a class="header-anchor" href="#_3-1-hash-模式和-history-模式的区别" aria-label="Permalink to &quot;3.1 hash 模式和 history 模式的区别&quot;">​</a></h3><p>Vue Router 的 hash 模式和 history 模式主要区别在于 URL 的表现形式和实现方式。</p><ol><li><strong>hash 模式</strong>：URL 中会出现 # 号，例如：<a href="http://example.com/#/home%E3%80%82hash" target="_blank" rel="noreferrer">http://example.com/#/home。hash</a> 模式的原理是基于 <code>window.location.hash</code> 的变化，来<strong>实现更新视图而不重新加载页面</strong>。hash 模式的核心特性是利用了浏览器对哈希的支持，使得页面在哈希值变化时不会重新加载全部内容。</li><li><strong>history 模式</strong>：URL 是普通路径形式，例如：<a href="http://example.com/home%E3%80%82history" target="_blank" rel="noreferrer">http://example.com/home。history</a> 模式的原理是基于 HTML5 的 <code>history.pushState</code> 和 <code>history.replaceState</code>，通过这两个 API 来<strong>操作浏览器历史记录，改变 URL 同时不重新加载页面</strong>。所以<strong>使用 history 模式时，需要在服务端进行配置，让所有路由都指向同一个入口页面，否则会出现 404 错误</strong>。</li></ol><h3 id="_3-2-route-和-router-的区别" tabindex="-1">3.2 route 和 router 的区别 <a class="header-anchor" href="#_3-2-route-和-router-的区别" aria-label="Permalink to &quot;3.2 route 和 router 的区别&quot;">​</a></h3><p>在 Vue Router 中，<code>route</code> 和 <code>router</code> 是截然不同的两个概念。简单来说，<code>route</code> 是一个<strong>当前路由信息对象</strong>，而 <code>router</code> 是 <strong>Vue Router 的实例</strong>。</p><ol><li><p>route</p><ul><li><p><code>route</code> 是针对当前活跃路由的对象， 它包含了当前路由的信息，比如路径（path）、参数（params）、查询参数（query）、路由匹配对象（matched）等。</p></li><li><p>举例：<code>this.$route</code>，你可以通过它来获取当前路由的信息，如 <code>this.$route.path</code> 获取当前路径。</p></li></ul></li><li><p>router</p><ul><li><code>router</code> 是 Vue Router 的实例，它包含控制路由的功能，比如跳转（navigations）、导航守卫（guards）等。</li><li>举例：<code>this.$router</code>，你可以通过它来执行路由导航，如 <code>this.$router.push(&#39;/home&#39;)</code> 进行页面跳转。</li></ul></li></ol><h3 id="_3-3-params-和-query-的区别" tabindex="-1">3.3 params 和 query 的区别 <a class="header-anchor" href="#_3-3-params-和-query-的区别" aria-label="Permalink to &quot;3.3 params 和 query 的区别&quot;">​</a></h3><p>在 Vue Router 中，<code>params</code> 和 <code>query</code> 是两种不同的传参方式：</p><ol><li><code>params</code>：用于<strong>动态路径参数</strong>，需要在路由配置中定义。例如 <code>/user/:id</code> 中的 <code>id</code> 是一个动态参数，你可以通过 <code>this.$route.params.id</code> 来获取它。<code>params</code> 更加隐蔽，不直接暴露在 URL 中。</li><li><code>query</code>：用于<strong>查询参数</strong>，使用前不需要在路由配置中定义。它们会以键值对的形式出现在 URL 的问号之后。例如 <code>/user?id=123</code>，你可以通过 <code>this.$route.query.id</code> 来获取 <code>id</code> 的值。<code>query</code> 更适合较为显性的参数传递和处理。</li></ol><h3 id="_3-4-路由之间是如何跳转的" tabindex="-1">3.4 路由之间是如何跳转的 <a class="header-anchor" href="#_3-4-路由之间是如何跳转的" aria-label="Permalink to &quot;3.4 路由之间是如何跳转的&quot;">​</a></h3><p>Vue Router 提供了两种基本的跳转方式：编程式导航和声明式导航。</p><ol><li><p><strong>编程式导航</strong>：</p><p>使用 <code>this.$router.push</code> 和 <code>this.$router.replace</code> 方法进行路由跳转。其中 <code>push</code> 方法会在浏览器的历史记录中增加一条新记录，而 <code>replace</code> 方法则会替换当前的历史记录。</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 编程式导航实例</span></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">$router</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">/home</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 跳转到/home路径</span></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">$router</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">replace</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">/login</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 跳转到/login路径，替换当前的路径</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li><p><strong>声明式导航</strong>：</p><p>通过 <code>&lt;router-link&gt;</code> 组件进行跳转。这种方式在模板中使用，使代码更清晰直观。</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;!--</span><span style="color:#A6ACCD;"> 声明式导航实例 </span><span style="color:#89DDFF;">--&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">router-link</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">to</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">/home</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Go to Home</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#FFCB6B;">router-link</span><span style="color:#89DDFF;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ol>`,21),l=[r];function n(i,p,c,u,d,h){return o(),a("div",null,l)}const D=e(t,[["render",n]]);export{m as __pageData,D as default};
