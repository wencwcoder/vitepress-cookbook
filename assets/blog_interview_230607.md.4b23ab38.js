import{_ as e,c as a,o as t,V as o}from"./chunks/framework.35c8bad0.js";const m=JSON.parse('{"title":"面试题[性能优化]","description":"","frontmatter":{"title":"面试题[性能优化]","date":"2023-06-07T00:00:00.000Z"},"headers":[],"relativePath":"blog/interview/230607.md","lastUpdated":1686230128000}'),r={name:"blog/interview/230607.md"},i=o('<h1 id="面试题-性能优化" tabindex="-1">面试题[性能优化] <a class="header-anchor" href="#面试题-性能优化" aria-label="Permalink to &quot;面试题[性能优化]&quot;">​</a></h1><h2 id="_1-什么情况下会重绘和回流-常见的改善方案" tabindex="-1">1. 什么情况下会重绘和回流，常见的改善方案 <a class="header-anchor" href="#_1-什么情况下会重绘和回流-常见的改善方案" aria-label="Permalink to &quot;1. 什么情况下会重绘和回流，常见的改善方案&quot;">​</a></h2><p>浏览器请求到对应页面资源的时候，会将 HTML 解析成 DOM，把 CSS 解析成 CSSDOM，然后将 DOM 和 CSSDOM 合并就产生了 Render Tree。在有了渲染树之后，浏览器会根据流式布局模型来计算它们在页面上的大小和位置，最后将节点绘制在页面上。</p><p>那么当 Render Tree 中部分或全部元素的尺寸、结构、或某些属性发生改变，浏览器就会重新渲染页面，这个就是浏览器的回流。常见的回流操作有：页面的首次渲染、浏览器窗口尺寸改变、部分元素尺寸或位置变化、添加或删除可见的 DOM、激活伪类、查询某些属性或调用方法（各种宽高的获取，滚动方法的执行等）。</p><p>当页面中元素样式的改变不影响它在文档流的位置时（如 color、background-color 等），这个就是重绘。</p><p><em><strong>回流必将导致重绘，重绘不一定会引起回流。回流比重绘的代价更高。</strong></em></p><p>常见的改善方案：</p><ul><li>在进行频繁操作的时候，使用节流和防抖来控制调用频率。</li><li>避免频繁操作 DOM，可以利用 DocumentFragment，来进行对应的 DOM 操作，将最后的结果添加到文档中。</li><li>灵活使用 display: none 属性，操作结束后将其显示出来，因为 display 的属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘。</li><li>获取各种会引起重绘/回流的属性，尽量将其缓存起来，不要频繁的去获取。</li><li>对复杂动画采用绝对定位，使其脱离文档流，否则它会频繁的引起父元素及其后续元素的回流。</li></ul><h2 id="_2-如何优化动画" tabindex="-1">2. 如何优化动画 <a class="header-anchor" href="#_2-如何优化动画" aria-label="Permalink to &quot;2. 如何优化动画&quot;">​</a></h2><p>一般情况下，动画需要频繁的操作 DOM，就会导致页面的性能问题，我们可以对复杂的动画采用<strong>绝对定位</strong>（position 属性设置为 absolute 或者 fixed），使其脱离文档流，这样它的回流就不会影响到页面其它元素了。</p>',10),n=[i];function l(s,_,d,c,p,h){return t(),a("div",null,n)}const D=e(r,[["render",l]]);export{m as __pageData,D as default};
