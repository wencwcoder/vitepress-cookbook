import{_ as s,c as e,o as a,V as l}from"./chunks/framework.35c8bad0.js";const u=JSON.parse('{"title":"面试题[React]","description":"","frontmatter":{"title":"面试题[React]","date":"2023-06-06T00:00:00.000Z"},"headers":[],"relativePath":"blog/interview/230606.md","lastUpdated":1732261617000}'),o={name:"blog/interview/230606.md"},n=l(`<h1 id="面试题-react" tabindex="-1">面试题[React] <a class="header-anchor" href="#面试题-react" aria-label="Permalink to &quot;面试题[React]&quot;">​</a></h1><h2 id="_1-react-基础知识" tabindex="-1">1. React 基础知识 <a class="header-anchor" href="#_1-react-基础知识" aria-label="Permalink to &quot;1. React 基础知识&quot;">​</a></h2><h3 id="_1-1-什么是-jsx-它与-html-有什么区别" tabindex="-1">1.1 什么是 JSX？它与 HTML 有什么区别？ <a class="header-anchor" href="#_1-1-什么是-jsx-它与-html-有什么区别" aria-label="Permalink to &quot;1.1 什么是 JSX？它与 HTML 有什么区别？&quot;">​</a></h3><p>JSX 是 JavaScript 语法的扩展，它允许编写类似于 HTML 的代码。它可以编译为常规的 JavaScript 函数调用，从而为创建组件标记提供了一种更好的方法。</p><div class="language-jsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// JSX代码如下</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">className</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">sidebar</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> /&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 转换为以下JS代码</span></span>
<span class="line"><span style="color:#A6ACCD;">React</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">createElement</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">div</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;">className</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">sidebar</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_1-2-function-component-和-class-component-的区别" tabindex="-1">1.2 Function Component 和 Class Component 的区别 <a class="header-anchor" href="#_1-2-function-component-和-class-component-的区别" aria-label="Permalink to &quot;1.2 Function Component 和 Class Component 的区别&quot;">​</a></h3><h3 id="_1-3-react-hooks" tabindex="-1">1.3 React Hooks <a class="header-anchor" href="#_1-3-react-hooks" aria-label="Permalink to &quot;1.3 React Hooks&quot;">​</a></h3><p>React Hooks 是 React 16.8 版本引入的一项特性，它允许在函数式组件中使用状态（state）和其他 React 特性，而不需要使用类组件。以下是对 React Hooks 的详细解释：</p><ol><li><p>基本概念</p><p>Hooks 就是钩子，作用是把某个目标结果“钩”到某个可能会变化的数据源或者事件源上。那么当被“钩”到的数据或事件发生变化时，产生这个目标结果的代码会重新执行，产生更新后的结果。</p></li><li><p>React Hooks 带来的优势</p><ul><li><strong>状态逻辑复用</strong>：通过自定义 Hooks，可以轻松地在多个组件之间复用状态逻辑。</li><li><strong>代码简洁性</strong>：Hooks 使得函数组件变得更加简洁和易于理解，避免了类组件中的复杂生命周期方法和状态管理。</li><li><strong>函数式编程</strong>：Hooks 拥抱了函数式编程，使得 React 组件的开发更加符合现代 JavaScript 的开发趋势。</li></ul></li><li><p>注意事项</p><ul><li><strong>避免过度使用Hooks</strong>：虽然Hooks提供了强大的功能，但过度使用可能会导致代码难以理解和维护。因此，在合适的时候使用Hooks是很重要的。</li><li><strong>注意Hooks的调用顺序</strong>：在函数组件中，Hooks的调用顺序必须是固定的。在组件的不同渲染中，Hooks的调用顺序应该保持一致。</li><li><strong>不要在循环、条件或嵌套函数中调用Hooks</strong>：这是React的一个规则，必须遵守以避免潜在的错误。</li></ul></li><li><p>解决了哪些问题</p><ul><li><strong>数据抽象</strong>、<strong>生命周期</strong>。</li><li>组件间状态逻辑复用困难。</li><li>复杂组件难以理解。</li><li>class 组件的学习和维护成本。</li><li>提供了更简洁和易于理解的代码。</li><li>更灵活的组件设计。</li><li>更易于测试。</li></ul></li></ol><h3 id="_1-4-react-suspence" tabindex="-1">1.4 React Suspence <a class="header-anchor" href="#_1-4-react-suspence" aria-label="Permalink to &quot;1.4 React Suspence&quot;">​</a></h3><p>会将 html 的读取过程变成 chunk 模式。（分块传输编码）</p><h3 id="_1-5-react-context" tabindex="-1">1.5 React Context <a class="header-anchor" href="#_1-5-react-context" aria-label="Permalink to &quot;1.5 React Context&quot;">​</a></h3><h3 id="_1-6-react-的错误边界-error-boundary" tabindex="-1">1.6 React 的错误边界 Error Boundary <a class="header-anchor" href="#_1-6-react-的错误边界-error-boundary" aria-label="Permalink to &quot;1.6 React 的错误边界 Error Boundary&quot;">​</a></h3><h3 id="_1-7-react-事件机制原理" tabindex="-1">1.7 React 事件机制原理 <a class="header-anchor" href="#_1-7-react-事件机制原理" aria-label="Permalink to &quot;1.7 React 事件机制原理&quot;">​</a></h3><p>React 的事件机制原理主要涉及到<strong>事件注册、事件合成、事件冒泡、事件派发</strong>等关键步骤，它虽然与原生 DOM 事件机制有所不同，但仍然是基于浏览器的事件机制完成的。以下是 React 事件机制原理的详细解释：</p><ol><li>事件注册： <ul><li><strong>React 并不将事件直接绑定到具体的 DOM 节点上，而是统一绑定到 <code>document</code> 上</strong>。</li><li>当组件挂载时，React 会根据组件内声明的事件类型（如 <code>onClick</code>、<code>onChange </code>等），给 <code>document</code> 添加事件监听，并指定统一的事件处理程序 <code>dispatchEvent</code>。</li><li>React 会将 React 组件内所有事件统一存放到一个对象（如 <code>listenerBank</code>）内，以便在触发事件时能够找到对应的方法去执行。</li></ul></li><li>事件合成（SyntheticEvent）： <ul><li>React 使用 <code>SyntheticEvent </code>作为所有事件的基类，该类定义了合成事件的基础公共属性和方法。</li><li>React 会根据当前的事件类型来使用不同的合成事件对象，如 <code>SyntheticMouseEvent</code>（鼠标事件）、<code>SyntheticFocusEvent</code>（焦点事件）等。</li><li><code>SyntheticEvent</code> 是 React 对原生事件的封装，处理了浏览器兼容问题，并且具有与原生事件相同的接口，如 <code>stopPropagation()</code> 和 <code>preventDefault()</code>。</li></ul></li><li>事件冒泡： <ul><li>React 中的事件传播遵循与原生 DOM 事件相似的机制，包括捕获阶段和冒泡阶段。</li><li>在 React 中，事件传播是通过组件的 props 来实现的。当一个组件触发一个事件时，React 会调用该组件的事件处理函数，并将事件对象作为参数传递给该函数。</li><li>默认情况下，React 中的事件处理程序在冒泡阶段被触发。如果需要处理捕获阶段的事件，可以使用如 <code>onClickCapture </code>的事件处理函数。</li></ul></li><li>事件派发（dispatchEvent）： <ul><li>React 通过 <code>dispatchEvent</code> 方法统一进行事件的派发。当事件触发时，React 会根据当前的组件 ID 和事件类型找到对应的事件回调函数并执行。</li><li>React 中的事件传播可以用于实现组件之间的通信和交互，如父组件可以通过 props 将事件处理函数传递给子组件，在子组件中触发该事件时，父组件可以捕获到该事件并执行相应的逻辑。</li></ul></li><li>其他特点： <ul><li>React 中的事件对象 <code>e</code> 是一个合成对象，而不是原生的事件对象。这个对象已经被 React 封装过，并且处理了浏览器兼容问题。</li><li>React 的事件命名方式采用驼峰命名法（如 <code>onClick</code>），与 DOM 的命名方式（如 <code>onclick</code>）有所不同。</li><li>在 React 中，不能通过返回 <code>false</code> 来阻止默认行为或阻止事件冒泡。需要显式调用 <code>e.preventDefault()</code> 或 <code>e.stopPropagation()</code> 来实现这些功能。</li></ul></li></ol><p>总结来说，React 的事件机制原理通过事件注册、事件合成、事件冒泡和事件派发等步骤实现了对事件的高效处理和管理。这种机制减少了内存消耗、提高了性能，并且为开发者提供了统一的规范和友好的开发体验。</p><h3 id="_1-8-react-异步机制" tabindex="-1">1.8 React 异步机制 <a class="header-anchor" href="#_1-8-react-异步机制" aria-label="Permalink to &quot;1.8 React 异步机制&quot;">​</a></h3><p>React的异步机制是其性能优化的关键部分，其底层逻辑主要涉及到调度器（Scheduler）、协调器（Reconciler）以及Fiber架构。以下是对React异步机制底层逻辑的详细解释：</p><ol><li><p>调度器（Scheduler）</p><p>调度器是React中负责任务调度的部分。它根据任务的优先级来决定任务的执行顺序，确保高优先级的任务能够优先得到执行。这种机制使得React在面对大量更新时，能够保持界面的流畅性，避免卡顿。</p></li><li><p>协调器（Reconciler）</p><p>协调器是React中负责对比新旧虚拟DOM（VDOM），并计算出最小DOM变化的部分。在React 16及以后的版本中，协调器采用了Fiber架构来实现异步更新。</p></li><li><p>Fiber架构</p><p>Fiber是React的最小工作单元，它代表了一个可以中断和恢复的更新过程。Fiber架构使得React能够将更新过程拆分成多个小的任务，并在浏览器的空闲时间中逐个执行这些任务。这种机制避免了长时间的阻塞操作，提高了应用的响应性。</p><p>具体来说，Fiber架构通过以下方式实现异步更新：</p><ol><li><strong>双树结构</strong>：Fiber架构中维护了两棵树，一棵是当前渲染的树（current Fiber Tree），另一棵是正在内存中构建的树（workInProgress Fiber Tree）。这两棵树通过alternate属性互相指向，方便在更新完成后进行切换。</li><li><strong>任务拆分</strong>：React会将更新过程拆分成多个小的任务（即Fiber节点），每个任务都包含了一定的更新逻辑。这些任务被放入一个任务队列中，等待调度器进行调度。</li><li><strong>时间片分配</strong>：调度器会根据任务的优先级和浏览器的空闲时间，为每个任务分配一个时间片。在时间片内，React会尽可能多地执行任务，直到时间片用完或任务队列为空。</li><li><strong>中断与恢复</strong>：如果在一个时间片内任务没有执行完，React会将当前任务的状态保存到内存中，并等待下一个时间片继续执行。这种机制使得React能够在浏览器的空闲时间中逐步完成更新过程，而不会阻塞其他操作。</li></ol></li><li><p>MessageChannel</p><p>React Scheduler <strong>使用 MessageChannel 的目的就是为了产生宏任务</strong>。为了实现：</p><ol><li>将主线程还给浏览器，以便浏览器更新页面。</li><li>浏览器更新页面后继续执行未完成的任务。</li></ol></li><li><p>异步更新的优势</p><ol><li><strong>提高性能</strong>：通过拆分任务和分配时间片，React能够充分利用浏览器的空闲时间进行更新操作，避免了长时间的阻塞操作，提高了应用的性能。</li><li><strong>优化用户体验</strong>：异步更新机制使得React能够更快地响应用户的输入和操作，减少了界面的卡顿和延迟，提高了用户体验。</li><li><strong>支持高优先级任务</strong>：调度器能够根据任务的优先级进行调度，确保高优先级的任务能够得到优先执行，进一步提高了应用的响应性和稳定性。</li></ol></li></ol><p>综上所述，React的异步机制通过调度器、协调器和Fiber架构的协同工作，实现了高效的异步更新过程。这种机制不仅提高了应用的性能，还优化了用户体验，使得React在面对大量更新时能够保持界面的流畅性和稳定性。</p><h3 id="_1-9-setstate-是同步还是异步的-setstate-做了什么" tabindex="-1">1.9 setState 是同步还是异步的，setState 做了什么 <a class="header-anchor" href="#_1-9-setstate-是同步还是异步的-setstate-做了什么" aria-label="Permalink to &quot;1.9 setState 是同步还是异步的，setState 做了什么&quot;">​</a></h3><p>在 React 中，<code>setState()</code> 函数通常被认为是异步的，这意味着调用<code>setState()</code> 时不会立刻改变 React 组件中 state 的值，setState 通过触发一次组件的更新来引发重绘，多次 setState 函数调用产生的效果会合并。</p><p>调用 setState 时，React 会做的第一件事情是将传递给 setState 的对象合并到组件的当前状态。这将启动一个称为和解（reconciliation）的过程。和解（reconciliation）的最终目标是以最有效的方式，根据这个新的状态来更新 UI。 为此，React 将构建一个新的 React 元素树（您可以将其视为 UI 的对象表示）。一旦有了这个树，为了弄清 UI 如何响应新的状态而改变，React 会将这个新树与上一个元素树相比较。</p><h3 id="_1-10-组件之间传递状态的方式" tabindex="-1">1.10 组件之间传递状态的方式 <a class="header-anchor" href="#_1-10-组件之间传递状态的方式" aria-label="Permalink to &quot;1.10 组件之间传递状态的方式&quot;">​</a></h3><p>在React中，组件之间传递状态（或称为数据）有几种主要的方式。以下是这些方式的详细解释和归纳：（<strong>跨组件共享数据</strong>）</p><ol><li>父组件向子组件传递状态： <ul><li>主要通过props进行传递。父组件将需要传递的状态作为props的一部分传递给子组件，子组件通过<code>this.props</code>（在类组件中）或函数参数（在函数组件中）访问这些props。</li></ul></li><li>父组件向更深层的子组件传递状态： <ul><li>如果需要向更深层的子组件传递状态，可以通过props的逐层传递来实现，但这可能会导致代码冗余和不易于维护。</li><li>使用Context API是一种更好的选择。Context提供了一个无需显式地通过每一个层级手动传递props的方式，就能将值深入组件树的手段。在父组件中创建一个Context，将需要传递的状态存储在Context中，然后通过<code>&lt;Context.Provider&gt;</code>将状态提供给子组件，子组件可以通过<code>&lt;Context.Consumer&gt;</code>或<code>useContext</code> Hook来访问这个状态。</li></ul></li><li>子组件向父组件传递状态： <ul><li>主要通过回调函数进行传递。在父组件中定义一个回调函数，并将其作为props传递给子组件。子组件可以调用这个回调函数，并将需要传递的状态作为参数传递给它。这样，父组件就可以在回调函数中获取到子组件传递的状态。</li></ul></li><li>没有任何嵌套关系的组件之间传递状态： <ul><li>例如，兄弟组件之间的状态传递，可以通过它们共同的父组件作为中介，利用父组件向子组件传递状态的方式，再结合子组件向父组件传递状态的方式，实现兄弟组件之间的状态传递。</li><li>使用Redux、MobX等全局状态管理库也是一种常见的选择。这些库可以在应用的顶层创建一个全局状态存储，并在任何组件中访问和更新这个状态。</li></ul></li><li>传递组件本身作为参数： <ul><li>这并不直接涉及状态的传递，但也是一种在React中传递组件的方式。可以通过传递JSX元素、直接传递组件本身，或者传递一个返回组件的函数来实现。这种方式主要用于动态渲染和组件复用。</li></ul></li><li>使用Hooks（如<code>useState</code>和<code>useReducer</code>） <ul><li>Hooks是React 16.8及以后版本提供的一种新特性，用于在函数组件中添加状态和其他React特性。虽然Hooks本身并不直接涉及组件之间的状态传递，但它们提供了一种在函数组件中管理状态的方式，从而可以与上述的传递方式结合使用。</li></ul></li></ol><p>综上所述，React组件之间传递状态的方式主要包括通过props的传递、使用Context API、通过回调函数、利用全局状态管理库以及传递组件本身作为参数等方式。具体使用哪种方式取决于应用的需求和架构。</p><h3 id="_1-11-受控组件和非受控组件的区别" tabindex="-1">1.11 受控组件和非受控组件的区别 <a class="header-anchor" href="#_1-11-受控组件和非受控组件的区别" aria-label="Permalink to &quot;1.11 受控组件和非受控组件的区别&quot;">​</a></h3><ul><li>受控组件：由 <strong>prop 驱动</strong>。</li><li>非受控组件：由自定义组件内部的 <strong>state 驱动</strong>。</li></ul><h3 id="_1-12-hooks-中为什么不能写判断" tabindex="-1">1.12 Hooks 中为什么不能写判断 <a class="header-anchor" href="#_1-12-hooks-中为什么不能写判断" aria-label="Permalink to &quot;1.12 Hooks 中为什么不能写判断&quot;">​</a></h3><ol><li>挂载阶段： <ul><li>创建 Hooks 链表。</li><li>执行链表。</li></ul></li><li>更新阶段： <ul><li>执行链表 --&gt; 校验是否可以执行。</li></ul></li></ol><h3 id="_1-13-usecallback-和-usememo-的区别" tabindex="-1">1.13 useCallBack 和 useMemo 的区别 <a class="header-anchor" href="#_1-13-usecallback-和-usememo-的区别" aria-label="Permalink to &quot;1.13 useCallBack 和 useMemo 的区别&quot;">​</a></h3><p><code>useCallback</code> 和 <code>useMemo</code> 是 React Hooks 中<strong>用于性能优化</strong>的两个重要工具。它们的主要区别在于用途、参数、返回值类型以及使用场景。以下是对两者区别的详细解释：</p><ol><li><p>功能不同：</p><ul><li><code>useCallback</code>：用于记忆化（memoize）回调函数，避免在每次渲染时都重新创建相同的函数。它接受一个回调函数和一个依赖项数组作为参数，当依赖项发生变化时，会返回一个新的记忆化的回调函数。</li><li><code>useMemo</code>：用于记忆化（memoize）计算结果，避免在每次渲染时都进行昂贵的计算。它接受一个计算函数和一个依赖项数组作为参数，当依赖项发生变化时，会重新计算并返回一个新的记忆化的计算结果。</li></ul></li><li><p>参数不同：</p><ul><li><code>useCallback</code>：接受一个回调函数和一个依赖项数组作为参数。</li><li><code>useMemo</code>：接受一个计算函数和一个依赖项数组作为参数。</li></ul></li><li><p>返回值类型不同：</p><ul><li><code>useCallback</code>：返回一个记忆化的回调函数。</li><li><code>useMemo</code>：返回一个记忆化的计算结果。</li></ul></li><li><p>使用场景不同：</p><ul><li><code>useCallback</code>：主要用于优化传递给子组件的回调函数，特别是当这些回调函数作为 props 传递，并且父组件频繁渲染时。通过使用 <code>useCallback</code>，可以确保子组件在 props 没有实际变化时不会重新渲染，从而提高性能。</li><li><code>useMemo</code>：主要用于优化计算操作，特别是当这些计算操作涉及复杂的计算或数据转换，并且这些计算的结果在多次渲染之间不会发生变化时。通过使用 <code>useMemo</code>，可以避免在每次渲染时都执行昂贵的计算，从而提高性能。</li></ul></li><li><p><strong>示例</strong>：</p><ul><li><p>使用 <code>useCallback</code> 优化回调函数：</p><div class="language-jsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> handleClick </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useCallback</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;">  </span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Button clicked!</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;">  </span></span>
<span class="line"><span style="color:#89DDFF;">},</span><span style="color:#A6ACCD;"> [])</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 依赖项数组为空，表示没有依赖项</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li><p>使用 <code>useMemo</code> 优化计算结果：</p><div class="language-jsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> expensiveValue </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useMemo</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">computeExpensiveValue</span><span style="color:#A6ACCD;">(a</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> b)</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> [a</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> b])</span><span style="color:#89DDFF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li></ul></li></ol><p>总结来说，<code>useCallback</code> 和 <code>useMemo</code> 都是用于性能优化的 React Hooks，但它们的用途、参数、返回值类型和使用场景有所不同。在实际开发中，可以根据具体的需求和场景选择使用哪个 Hook 来提高应用的性能。</p><h3 id="_1-14-useref-和-ref-的区别" tabindex="-1">1.14 useRef 和 ref 的区别 <a class="header-anchor" href="#_1-14-useref-和-ref-的区别" aria-label="Permalink to &quot;1.14 useRef 和 ref 的区别&quot;">​</a></h3><p><code>useRef</code> 和 <code>ref</code> 在 React 中都是<strong>用于访问 DOM 元素或组件实例</strong>的工具，但它们在使用方式、适用场景以及实现原理上存在明显的区别。以下是关于 <code>useRef</code> 和 <code>ref</code> 的详细区别：</p><ol><li>使用方式： <ul><li><code>ref</code>：在类组件中，通常使用 <code>React.createRef()</code> 方法来创建一个 ref 对象，并将其赋值给类的一个实例属性。然后，可以通过这个 ref 属性来访问对应的 DOM 元素或组件实例。在函数组件中，<code>ref</code> 不能直接使用，因为函数组件没有实例。</li><li><code>useRef</code>：是 React 提供的一个 Hook，专门用于函数组件中。它返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数（通常是 <code>null</code>）。这个 ref 对象在整个组件的生命周期内保持不变，可以用来保存任何可变的值，不仅仅是 DOM 元素或组件实例。</li></ul></li><li>适用场景： <ul><li><code>ref</code>：主要用于类组件中，通过 ref 可以访问到子组件的实例或 DOM 元素，从而进行一些需要直接操作 DOM 或组件实例的操作，如读取输入值、设置焦点等。</li><li><code>useRef</code>：在函数组件中替代了 <code>ref</code> 的功能，并且功能更为强大。除了用于访问 DOM 元素或组件实例外，<code>useRef</code> 还可以用来保存一些不需要触发组件重新渲染的状态，如定时器、上一次的渲染结果等。此外，<code>useRef</code> 还可以用来绕过闭包问题，确保回调函数或定时器能够获取到最新的变量值。</li></ul></li><li>实现原理： <ul><li><code>ref</code>：在类组件中，<code>ref</code> 是通过实例属性来实现的。在创建组件实例时，React 会将 <code>ref</code> 属性所指向的回调函数或 <code>createRef()</code> 创建的 ref 对象存储到组件实例上，从而可以在组件内部通过 <code>this.refs</code> 或直接访问 ref 对象来访问到对应的 DOM 元素或组件实例。</li><li><code>useRef</code>：在函数组件中，由于没有实例，React 通过 <code>useRef</code> Hook 来实现 ref 的功能。<code>useRef</code> 返回一个可变的 ref 对象，这个对象在组件的整个生命周期内保持不变。当组件重新渲染时，<code>useRef</code> 会返回同一个 ref 对象，从而避免了不必要的重新创建和重新赋值。</li></ul></li><li>注意事项： <ul><li>在使用 <code>ref</code> 时，需要注意不要在渲染过程中读取或修改 ref 的值，因为这可能会导致不可预测的结果。</li><li><code>useRef</code> 返回一个可变的 ref 对象，但不应该在渲染过程中读取或修改 ref 的 <code>.current</code> 属性。通常，我们只在事件处理函数、生命周期方法或副作用（如 <code>useEffect</code>）中读取或修改 ref 的 <code>.current</code> 属性。</li></ul></li></ol><p>总结来说，<code>useRef</code> 和 <code>ref</code> 都是用于访问 DOM 元素或组件实例的工具，但它们在使用方式、适用场景以及实现原理上存在差异。在函数组件中，我们通常使用 <code>useRef</code> 来替代 <code>ref</code> 的功能。</p><h3 id="_1-15-useeffect-和-uselayouteffect-的区别" tabindex="-1">1.15 useEffect 和 useLayoutEffect 的区别 <a class="header-anchor" href="#_1-15-useeffect-和-uselayouteffect-的区别" aria-label="Permalink to &quot;1.15 useEffect 和 useLayoutEffect 的区别&quot;">​</a></h3><ul><li>useEffect：DOM 更新前调用，微任务调用，页面渲染之后执行。适用于：纯数据处理。</li><li>useLayoutEffect：DOM 更新后调用，同步调用，页面渲染之前执行。适用于：数据修改之后要操作 DOM，防止重复渲染。</li></ul><p>注意：DOM 更新 --&gt; 页面渲染（顺序）。</p><h2 id="_2-react-拓展知识" tabindex="-1">2. React 拓展知识 <a class="header-anchor" href="#_2-react-拓展知识" aria-label="Permalink to &quot;2. React 拓展知识&quot;">​</a></h2><h3 id="_2-1-函数式编程是什么-有哪些应用场景" tabindex="-1">2.1 函数式编程是什么？有哪些应用场景？ <a class="header-anchor" href="#_2-1-函数式编程是什么-有哪些应用场景" aria-label="Permalink to &quot;2.1 函数式编程是什么？有哪些应用场景？&quot;">​</a></h3><p>函数式编程（Functional Programming，简称 FP）是一种编程范式，它将计算机程序视为数学中的函数计算，强调函数的输入输出是确定的，不会受到外部状态的影响。函数式编程一般采用无副作用、不可变数据等特性，使得代码更加模块化、可复用、易于测试和推理等。</p><p>函数式编程中的函数是一等公民，即可以像其他类型的数据一样被传递、赋值、返回等。函数式编程也强调函数的高阶抽象能力，通过组合和柯里化等技巧实现复杂的功能。</p><p>函数式编程适用于需要处理大量数据的场景，例如数据分析、机器学习、图像处理等。在这些场景中，函数式编程的无副作用、不可变数据等特性可以提高程序的性能和稳定性。函数式编程还适用于需要编写高度可复用的代码库、需要构建高层次抽象的系统等场景。</p><p>除此之外，函数式编程还可以用于实现异步编程、事件驱动编程、响应式编程等，它们都是函数式编程的应用场景。例如在 JavaScript 中，Promise 和 RxJS 都是基于函数式编程的思想实现的。</p><p>总之，函数式编程是一种强调函数抽象、模块化、不可变性等特性的编程范式，适用于处理大量数据、实现高度可复用代码库、构建高层次抽象的系统等场景。</p><h3 id="_2-2-函数式编程中的无副作用" tabindex="-1">2.2 函数式编程中的无副作用 <a class="header-anchor" href="#_2-2-函数式编程中的无副作用" aria-label="Permalink to &quot;2.2 函数式编程中的无副作用&quot;">​</a></h3><p>函数式编程的一个核心概念是无副作用（Referential Transparency），也就是函数的执行只依赖于输入参数，不会对外部环境产生影响。副作用指的是函数执行过程中对外部环境进行了修改或产生了其他可观察的行为，比如修改全局变量、写入文件、发送网络请求等。</p><p>函数式编程强调无副作用的好处在于：</p><ol><li>可靠性：由于函数的结果仅取决于输入参数，相同的输入永远得到相同的输出，不会受到外部环境的变化影响，因此更容易推断和验证函数的行为。</li><li>可测试性：函数无副作用意味着可以更容易地进行单元测试，只需关注输入和输出，而无需关心函数内部的状态变化。</li><li>可组合性：无副作用的函数更容易进行组合，通过将多个函数连接在一起，形成更复杂的功能，而不需要担心它们之间的相互影响。</li></ol><p>然而，并非所有的程序都可以完全避免副作用，因为现实世界中很多任务都需要与外部环境进行交互。在函数式编程中，通常会将具有副作用的操作封装在纯函数的边界之外，以保持主要的业务逻辑的纯洁性。</p><p>函数式编程并不是要完全消除副作用，而是通过限制和管理副作用的方式来提高程序的可靠性、可测试性和可组合性。</p><h3 id="_2-3-react-应用的生产环境中-怎么定位到具体错误代码行数" tabindex="-1">2.3 React 应用的生产环境中，怎么定位到具体错误代码行数 <a class="header-anchor" href="#_2-3-react-应用的生产环境中-怎么定位到具体错误代码行数" aria-label="Permalink to &quot;2.3 React 应用的生产环境中，怎么定位到具体错误代码行数&quot;">​</a></h3><p>在 React 应用的生产环境中，要定位具体的错误代码行数，可以采取以下几种方法：</p><ol><li><strong>使用 Source Map</strong>： <ul><li>在构建生产版本时生成 Source Map 文件。Source Map 是一个映射文件，可以将压缩后的代码映射回原始的开发代码，包括行数、列数等信息。</li><li>当生产环境中出现错误时，浏览器会根据 Source Map 将错误定位到原始代码的行数和列数，从而帮助你准确定位问题所在。</li></ul></li><li><strong>错误边界（Error Boundary）</strong>： <ul><li>在 React 应用中使用错误边界来捕获并处理组件中的错误。你可以在错误边界的 <code>componentDidCatch</code> 方法中记录错误信息，包括错误的堆栈信息。</li><li>在错误信息中包含堆栈信息，可以帮助你定位到具体出错的组件和代码行数。</li></ul></li><li><strong>使用监控和日志工具</strong>： <ul><li>集成监控和日志工具，如 Sentry、Bugsnag 等，这些工具可以捕获前端错误，并提供详细的错误信息，包括出错的文件、行数等。</li><li>通过这些工具提供的错误报告，你可以快速定位到具体的代码行数，并了解错误发生的上下文信息。</li></ul></li><li><strong>手动添加调试信息</strong>： <ul><li>在代码中添加额外的调试信息，例如使用 <code>console.log</code> 输出变量的值或标识代码执行到了哪个阶段。</li><li>这种方法虽然相对简单，但需要手动添加代码，并且可能会影响代码的性能和可读性。</li></ul></li><li><strong>使用浏览器开发者工具</strong>： <ul><li>在浏览器的开发者工具中，可以查看 JavaScript 控制台中的错误信息，并通过点击错误信息来跳转到具体的代码行数。</li><li>这种方法适用于快速定位到错误发生的地方，但可能无法精确定位到原始的开发代码行数，特别是在代码经过压缩和混淆的情况下。</li></ul></li></ol><p>综上所述，结合使用 Source Map、错误边界、监控工具和浏览器开发者工具，可以帮助你在 React 应用的生产环境中准确定位到具体的错误代码行数。</p><h3 id="_2-4-react-应用中实现页面切换时保存数据不丢失并记忆滚动条位置" tabindex="-1">2.4 React 应用中实现页面切换时保存数据不丢失并记忆滚动条位置 <a class="header-anchor" href="#_2-4-react-应用中实现页面切换时保存数据不丢失并记忆滚动条位置" aria-label="Permalink to &quot;2.4 React 应用中实现页面切换时保存数据不丢失并记忆滚动条位置&quot;">​</a></h3><p>在 React 应用中实现页面切换时保存数据不丢失并记忆滚动条位置，可以采取以下几种优化策略，以提升用户体验并减少页面闪烁：</p><p>1、使用 React Router 中的 <code>&lt;Route&gt;</code> 组件的 <code>key</code> 属性：</p><p>在 <code>&lt;Route&gt;</code> 组件中设置唯一的 <code>key</code> 属性，使得当路由切换时，React 不会重新渲染相同的组件，而是复用已经挂载过的组件，从而保留组件的状态和数据。</p><div class="language-jsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Route</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">location</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">pathname</span><span style="color:#89DDFF;">} </span><span style="color:#C792EA;">path</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">/</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">exact</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">component</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">Home</span><span style="color:#89DDFF;">} /&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Route</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">location</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">pathname</span><span style="color:#89DDFF;">} </span><span style="color:#C792EA;">path</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">/about</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">component</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">About</span><span style="color:#89DDFF;">} /&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>2、在组件中使用 <code>React.memo</code> 进行优化：</p><p>对于纯函数组件，可以使用 <code>React.memo</code> 进行包裹，以避免不必要的重新渲染。这样可以确保页面切换时只有必要的组件会重新渲染，减少页面闪烁。</p><div class="language-jsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> MemoizedComponent </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> React</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">memo</span><span style="color:#A6ACCD;">(MyComponent)</span><span style="color:#89DDFF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>3、使用 <code>window.sessionStorage</code> 或 <code>window.localStorage</code> 进行数据存储：</p><p>在组件卸载前将需要保存的数据存储到 <code>sessionStorage</code> 或 <code>localStorage</code> 中，在组件重新挂载时再从中恢复数据。这样可以确保数据不会在页面切换时丢失。</p><p>4、记忆滚动条位置：</p><ul><li>在页面切换时，监听 <code>window</code> 的 <code>scroll</code> 事件，将滚动条位置保存到状态或 <code>sessionStorage</code> 中。</li><li>在页面重新加载或切换回来时，从状态或 <code>sessionStorage</code> 中恢复滚动条位置，使得用户可以无缝地恢复到之前的滚动位置。</li></ul><p>5、使用 React 的 <code>useEffect</code> 钩子进行数据保存和恢复：</p><p>在组件中使用 <code>useEffect</code> 钩子监听组件的卸载和挂载事件，在卸载前将需要保存的数据存储起来，在挂载时再从存储中恢复数据。</p><div class="language-jsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">useEffect</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 在组件卸载前保存数据</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 在组件重新挂载时恢复数据</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">},</span><span style="color:#A6ACCD;"> [])</span><span style="color:#89DDFF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>通过以上优化策略，可以在页面切换时保持数据不丢失并记忆滚动条位置，同时减少页面闪烁，提升用户体验。</p><h3 id="_2-5-react-中的性能优化有哪些常见的技巧" tabindex="-1">2.5 React 中的性能优化有哪些常见的技巧 <a class="header-anchor" href="#_2-5-react-中的性能优化有哪些常见的技巧" aria-label="Permalink to &quot;2.5 React 中的性能优化有哪些常见的技巧&quot;">​</a></h3><h3 id="_2-6-ssr-和-rsc-的区别" tabindex="-1">2.6 SSR 和 RSC 的区别 <a class="header-anchor" href="#_2-6-ssr-和-rsc-的区别" aria-label="Permalink to &quot;2.6 SSR 和 RSC 的区别&quot;">​</a></h3><h2 id="_3-react-底层原理" tabindex="-1">3. React 底层原理 <a class="header-anchor" href="#_3-react-底层原理" aria-label="Permalink to &quot;3. React 底层原理&quot;">​</a></h2><h3 id="_3-1-fiber-架构" tabindex="-1">3.1 Fiber 架构 <a class="header-anchor" href="#_3-1-fiber-架构" aria-label="Permalink to &quot;3.1 Fiber 架构&quot;">​</a></h3><h3 id="_3-2-messagechannel" tabindex="-1">3.2 MessageChannel <a class="header-anchor" href="#_3-2-messagechannel" aria-label="Permalink to &quot;3.2 MessageChannel&quot;">​</a></h3><p>在React中，<code>MessageChannel</code>是一个Web API，它允许我们在不同的浏览上下文（如窗口、iframe或Web Worker）之间建立通信管道。这个API对于React应用来说，虽然不直接用于组件的状态管理或渲染，但在某些特定的<strong>异步通信</strong>场景中可能会非常有用。以下是对React中异步<code>MessageChannel</code>的详细解释：</p><ol><li><p><code>MessageChannel</code>的基本概念</p><p><code>MessageChannel</code>接口创建了一个新的消息通道，这个通道有两个端口（<code>port1</code>和<code>port2</code>），它们可以互相发送消息。这些消息是以DOM Event的形式发送的，因此它们是异步的。</p></li><li><p><code>MessageChannel</code>在React中的应用场景</p><ol><li><strong>跨窗口或iframe通信</strong>： <ul><li>在React应用中，如果需要在主窗口和iframe之间传递消息，<code>MessageChannel</code>可以提供一个安全且高效的方式。</li><li>父窗口可以创建一个<code>MessageChannel</code>，并将<code>port2</code>通过<code>postMessage</code>方法传递给iframe。然后，父窗口和iframe就可以通过各自的端口进行双向通信。</li></ul></li><li><strong>Web Worker通信</strong>： <ul><li>Web Worker是在后台线程中运行JavaScript代码的一种方式，它不会阻塞主线程。</li><li>在React应用中，如果需要使用Web Worker来处理耗时任务，<code>MessageChannel</code>可以用于在主线程和Worker之间传递消息。</li><li>需要注意的是，由于<code>MessagePort</code>是可传输对象（Transferable Objects），因此它可以在<code>postMessage</code>方法中被传递，从而在Worker中获得并使用。</li></ul></li></ol></li><li><p>使用<code>MessageChannel</code>的注意事项</p><ol><li><strong>安全性</strong>： <ul><li>在使用<code>MessageChannel</code>进行跨窗口或iframe通信时，要确保只向受信任的上下文传递端口。</li><li>避免在不受信任的上下文中暴露过多的能力，以防止潜在的安全风险。</li></ul></li><li><strong>资源管理</strong>： <ul><li>在通信结束后，应主动调用<code>close</code>方法来断开<code>MessagePort</code>的连接，以便回收资源。</li><li>如果不再需要<code>MessageChannel</code>，可以考虑将其删除或置为<code>null</code>，以避免内存泄漏。</li></ul></li><li><strong>兼容性</strong>： <ul><li>尽管<code>MessageChannel</code>在现代浏览器中得到了广泛的支持，但在使用之前仍应检查浏览器的兼容性。</li><li>对于不支持<code>MessageChannel</code>的浏览器，可以考虑使用其他通信方式（如<code>localStorage</code>、<code>sessionStorage</code>或第三方库）作为替代方案。</li></ul></li></ol></li><li><p>示例代码</p><p>以下是一个简单的示例，展示了如何在React应用中使用<code>MessageChannel</code>进行跨窗口通信：</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 父窗口代码</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> port1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> port2 </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">MessageChannel</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 监听来自iframe的消息</span></span>
<span class="line"><span style="color:#A6ACCD;">port1</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">onmessage</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">event</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Received message from iframe:</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">event</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">data</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 将port2传递给iframe</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> iframe </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">querySelector</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">iframe</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">iframe</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">contentWindow</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">postMessage</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Hello from parent!</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">*</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> [port2])</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// iframe代码（假设在另一个HTML文件中）</span></span>
<span class="line"><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">onmessage</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">event</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">event</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">ports</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">length</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&gt;</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">port</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">event</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">ports</span><span style="color:#F07178;">[</span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">]</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 监听来自父窗口的消息</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">port</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">onmessage</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">event</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Received message from parent:</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">event</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">data</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// 向父窗口发送消息</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">port</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">postMessage</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Hello from iframe!</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>在这个示例中，父窗口创建了一个<code>MessageChannel</code>，并将<code>port2</code>传递给了一个iframe。然后，父窗口和iframe通过各自的端口进行双向通信。</p></li></ol><p>总的来说，<code>MessageChannel</code>在React应用中可以用于处理特定的异步通信场景。然而，对于大多数React应用来说，使用React的状态管理机制（如<code>useState</code>、<code>useReducer</code>等）和React的上下文（Context）API来处理组件之间的通信可能更为常见和直观。</p>`,85),p=[n];function c(t,r,i,d,D,y){return a(),e("div",null,p)}const C=s(o,[["render",c]]);export{u as __pageData,C as default};
