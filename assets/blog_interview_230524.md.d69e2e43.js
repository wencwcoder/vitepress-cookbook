import{_ as a,c as s,o as n,V as l}from"./chunks/framework.35c8bad0.js";const u=JSON.parse('{"title":"面试题[JavaScript]","description":"","frontmatter":{"title":"面试题[JavaScript]","date":"2023-05-24T00:00:00.000Z"},"headers":[],"relativePath":"blog/interview/230524.md","lastUpdated":1731033334000}'),e={name:"blog/interview/230524.md"},o=l(`<h1 id="面试题-javascript" tabindex="-1">面试题[JavaScript] <a class="header-anchor" href="#面试题-javascript" aria-label="Permalink to &quot;面试题[JavaScript]&quot;">​</a></h1><h2 id="_1-javascript-基础知识" tabindex="-1">1. JavaScript 基础知识 <a class="header-anchor" href="#_1-javascript-基础知识" aria-label="Permalink to &quot;1. JavaScript 基础知识&quot;">​</a></h2><h3 id="_1-1-数据类型" tabindex="-1">1.1 数据类型 <a class="header-anchor" href="#_1-1-数据类型" aria-label="Permalink to &quot;1.1 数据类型&quot;">​</a></h3><p>JavaScript 中将数据类型分为基本数据类型和引用数据类型，它们其中有一个区别就是存储的位置不同。</p><p>基本数据类型：boolean、string、number、undefined、null、symbol、bigint。</p><p>引用数据类型：array、object。</p><h3 id="_1-2-typeof-和-instanceof-的区别" tabindex="-1">1.2 typeof 和 instanceof 的区别 <a class="header-anchor" href="#_1-2-typeof-和-instanceof-的区别" aria-label="Permalink to &quot;1.2 typeof 和 instanceof 的区别&quot;">​</a></h3><p>instanceof 原理手写</p><h3 id="_1-3-typeof-null-的结果是什么-为什么" tabindex="-1">1.3 typeof null 的结果是什么？为什么？ <a class="header-anchor" href="#_1-3-typeof-null-的结果是什么-为什么" aria-label="Permalink to &quot;1.3 typeof null 的结果是什么？为什么？&quot;">​</a></h3><p>在 JavaScript 中，<code>typeof null</code> 的结果是 <code>&quot;object&quot;</code>。这是一个历史遗留问题，而不是出于设计上的考虑。</p><p>在 JavaScript 中，所有事物都是对象，但有一个例外：<code>null</code>。然而，为了简化类型检测，<code>typeof</code> 操作符对于原始数据类型（如 <code>number</code>、<code>string</code>、<code>boolean</code>）返回的是它们的小写形式字符串（如 <code>&quot;number&quot;</code>、<code>&quot;string&quot;</code>、<code>&quot;boolean&quot;</code>），但对于复杂的数据类型（如对象和函数），它返回的是 <code>&quot;object&quot;</code>。</p><p>原因可以追溯到 JavaScript 的早期版本，特别是 ECMAScript 3 和更早的版本。在 JavaScript 最初的实现中，JavaScript 中的值是由一个<strong>表示类型的标签和实际数据值</strong>表示的。对象的类型标签是 0。由于 <code>null</code> 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，<code>typeof null</code> 也因此返回 <code>&quot;object&quot;</code>。（<a href="https://www.2ality.com/2013/10/typeof-null.html" target="_blank" rel="noreferrer">参考来源 (opens new window)</a>）</p><p>曾有一个 ECMAScript 的修复提案（通过选择性加入的方式），但<a href="http://wiki.ecmascript.org/doku.php?id=harmony:typeof_null" target="_blank" rel="noreferrer">被拒绝了 (opens new window)</a>。该提案会导致 <code>typeof null === &quot;null&quot;</code>。</p><h3 id="_1-4-字符串的常用方法" tabindex="-1">1.4 字符串的常用方法 <a class="header-anchor" href="#_1-4-字符串的常用方法" aria-label="Permalink to &quot;1.4 字符串的常用方法&quot;">​</a></h3><h3 id="_1-5-数组的常用方法" tabindex="-1">1.5 数组的常用方法 <a class="header-anchor" href="#_1-5-数组的常用方法" aria-label="Permalink to &quot;1.5 数组的常用方法&quot;">​</a></h3><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 判断变量是否是数组</span></span>
<span class="line"><span style="color:#A6ACCD;">Array</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isArray</span><span style="color:#A6ACCD;">(arr)</span></span>
<span class="line"><span style="color:#A6ACCD;">arr </span><span style="color:#89DDFF;">instanceof</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Array</span></span>
<span class="line"><span style="color:#FFCB6B;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">toString</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#A6ACCD;">(arr) </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">[object Array]</span><span style="color:#89DDFF;">&#39;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_1-6-对象的常用方法" tabindex="-1">1.6 对象的常用方法 <a class="header-anchor" href="#_1-6-对象的常用方法" aria-label="Permalink to &quot;1.6 对象的常用方法&quot;">​</a></h3><h3 id="_1-7-变量提升" tabindex="-1">1.7 变量提升 <a class="header-anchor" href="#_1-7-变量提升" aria-label="Permalink to &quot;1.7 变量提升&quot;">​</a></h3><h3 id="_1-8-闭包和作用域" tabindex="-1">1.8 闭包和作用域 <a class="header-anchor" href="#_1-8-闭包和作用域" aria-label="Permalink to &quot;1.8 闭包和作用域&quot;">​</a></h3><details class="details custom-block"><summary>闭包定义</summary><p>根据 JavaScript 中的词法作用域规则，内部函数总是可以访问其外部函数中声明的变量。当内部函数被返回到外部函数之外时，即使外部函数执行结束了，但是内部函数引用了外部函数的变量，这些变量仍然会被保存在内存中。这个现象称为闭包。</p></details><p>JavaScript 中常见的作用域包括全局作用域、函数作用域、块级作用域。</p><p>JavaScript 中自由变量的查找是在<strong>函数定义</strong>的地方，向上级作用域查找，不是在执行的地方。</p><p>闭包是作用域应用的特殊场景。常见的闭包使用有两种场景：一种是函数作为参数被传递；一种是函数作为返回值被返回。</p><p>怎么看待闭包的副作用？</p><h3 id="_1-9-原型和原型链" tabindex="-1">1.9 原型和原型链 <a class="header-anchor" href="#_1-9-原型和原型链" aria-label="Permalink to &quot;1.9 原型和原型链&quot;">​</a></h3><h3 id="_1-10-javascript-执行上下文、执行栈和闭包" tabindex="-1">1.10 JavaScript 执行上下文、执行栈和闭包 <a class="header-anchor" href="#_1-10-javascript-执行上下文、执行栈和闭包" aria-label="Permalink to &quot;1.10 JavaScript 执行上下文、执行栈和闭包&quot;">​</a></h3><h3 id="_1-11-对-this-的理解" tabindex="-1">1.11 对 this 的理解 <a class="header-anchor" href="#_1-11-对-this-的理解" aria-label="Permalink to &quot;1.11 对 this 的理解&quot;">​</a></h3><h3 id="_1-12-new-操作符做了什么" tabindex="-1">1.12 new 操作符做了什么 <a class="header-anchor" href="#_1-12-new-操作符做了什么" aria-label="Permalink to &quot;1.12 new 操作符做了什么&quot;">​</a></h3><h3 id="_1-13-继承" tabindex="-1">1.13 继承 <a class="header-anchor" href="#_1-13-继承" aria-label="Permalink to &quot;1.13 继承&quot;">​</a></h3><p><a href="/vitepress-cookbook/frontend/javascript/240610">JavaScript实现继承</a></p><h3 id="_1-14-事件模型" tabindex="-1">1.14 事件模型 <a class="header-anchor" href="#_1-14-事件模型" aria-label="Permalink to &quot;1.14 事件模型&quot;">​</a></h3><p>事件冒泡（Event Bubbling）、事件捕获（Event Capturing）、事件委托（Event Delegation）。</p><h3 id="_1-15-事件循环" tabindex="-1">1.15 事件循环 <a class="header-anchor" href="#_1-15-事件循环" aria-label="Permalink to &quot;1.15 事件循环&quot;">​</a></h3><p><a href="/vitepress-cookbook/frontend/javascript/240529">JavaScript事件循环机制</a></p><h3 id="_1-16-javascript-中的异步编程" tabindex="-1">1.16 JavaScript 中的异步编程 <a class="header-anchor" href="#_1-16-javascript-中的异步编程" aria-label="Permalink to &quot;1.16 JavaScript 中的异步编程&quot;">​</a></h3><h3 id="_1-17-javascript-中的严格模式" tabindex="-1">1.17 JavaScript 中的严格模式 <a class="header-anchor" href="#_1-17-javascript-中的严格模式" aria-label="Permalink to &quot;1.17 JavaScript 中的严格模式&quot;">​</a></h3><h2 id="_2-javascript-拓展知识" tabindex="-1">2. JavaScript 拓展知识 <a class="header-anchor" href="#_2-javascript-拓展知识" aria-label="Permalink to &quot;2. JavaScript 拓展知识&quot;">​</a></h2><h3 id="_2-1-ecma-标准从提案到发布有几个阶段-哪个阶段是具有里程碑意义的" tabindex="-1">2.1 ECMA 标准从提案到发布有几个阶段？哪个阶段是具有里程碑意义的 <a class="header-anchor" href="#_2-1-ecma-标准从提案到发布有几个阶段-哪个阶段是具有里程碑意义的" aria-label="Permalink to &quot;2.1 ECMA 标准从提案到发布有几个阶段？哪个阶段是具有里程碑意义的&quot;">​</a></h3><p>ECMA标准从提案到发布经历了以下几个阶段：</p><ol><li>Stage 0 - Strawman（草案）：这个阶段是最初的提案阶段，通常由个人或小组提出，并还没有经过正式的标准化流程。提案可能只是一个想法或初步的概念。</li><li>Stage 1 - Proposal（提案）：在这个阶段，提案开始进入正式的标准化流程。提案需要详细说明其功能、语法和语义，并且需要提供示例代码和使用案例。</li><li>Stage 2 - Draft（草稿）：在这个阶段，提案转化为一份详细的草稿，其中包含了具体的语法规范和语义定义。草稿需要经过审查和讨论，并且需要有多个独立实现的证明。</li><li>Stage 3 - Candidate（候选）：在这个阶段，提案已经足够成熟，可以被视为候选标准。这意味着提案已经通过了实际应用并经过广泛的测试和实现。</li><li>Stage 4 - Finished（完成）：在这个阶段，提案被接受为最终的标准，已经准备好发布。提案的规范细节已经完善，并且已经有多个独立实现通过了所有测试。</li></ol><p>这些阶段代表了ECMA标准的不同发展阶段，其中最具里程碑意义的是Stage 4 - Finished（完成）阶段。在这个阶段，提案被接受为最终的标准，意味着它已经经过了广泛的实现、测试和审查，并被认为是稳定和可靠的。完成阶段的标准可以被广泛采用和应用于实际的编程环境中。</p><h3 id="_2-2-不创建新变量的前提下-如何交换两个变量的位置" tabindex="-1">2.2 不创建新变量的前提下，如何交换两个变量的位置 <a class="header-anchor" href="#_2-2-不创建新变量的前提下-如何交换两个变量的位置" aria-label="Permalink to &quot;2.2 不创建新变量的前提下，如何交换两个变量的位置&quot;">​</a></h3><ul><li>解构赋值：适用于数组、对象和其他可迭代的数据结构。</li></ul><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">20</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">[a</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> b] </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> [b</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> a]</span><span style="color:#89DDFF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>位运算符 -- 位异或（^）运算符：只适用于数字类型的变量。</li></ul><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">^</span><span style="color:#A6ACCD;"> b</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">^</span><span style="color:#A6ACCD;"> b</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">^</span><span style="color:#A6ACCD;"> b</span><span style="color:#89DDFF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>加法和减法、乘法和除法：只适用于数字类型的变量。</li></ul><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> b</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> b</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> b</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> b</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;"> b</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;"> b</span><span style="color:#89DDFF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="_2-3-javascript-文件相互引用有什么问题" tabindex="-1">2.3 JavaScript 文件相互引用有什么问题 <a class="header-anchor" href="#_2-3-javascript-文件相互引用有什么问题" aria-label="Permalink to &quot;2.3 JavaScript 文件相互引用有什么问题&quot;">​</a></h3><p>可能导致代码执行错误或者无法正常工作。下面是一些常见的问题及其解决方法：</p><ol><li><strong>循环依赖（Circular Dependency）</strong>： 循环依赖指的是两个或多个模块相互依赖，直接或间接地引用对方，导致模块无法正确加载。解决循环依赖问题的方法包括： <ul><li>重构代码结构，将共享的逻辑抽离到单独的模块中，避免直接相互引用。</li><li>使用异步加载模块的方式，如 <code>import()</code> 动态导入语法，可以延迟加载模块，避免循环依赖问题。</li></ul></li><li><strong>加载顺序错误</strong>： 当 JavaScript 文件相互引用时，确保它们之间的加载顺序是正确的非常重要。如果加载顺序错误，可能会导致某些模块在使用时还未被加载，从而出现错误。解决加载顺序错误的方法包括： <ul><li>明确定义模块之间的依赖关系，确保先加载依赖的模块，再加载依赖它们的模块。</li><li>使用模块打包工具（如 Webpack、Rollup 等）来管理模块之间的依赖关系和加载顺序，确保打包后的文件能正确加载所有模块。</li></ul></li><li><strong>使用命名导出和默认导出</strong>： 在模块间引用时，可以使用命名导出和默认导出来更清晰地定义模块之间的关系。通过明确导出和导入需要的函数、变量等，可以减少不必要的引用问题。</li><li><strong>使用事件订阅/发布模式</strong>： 如果存在模块之间需要通信的情况，可以考虑使用事件订阅/发布模式（Event Emitter），模块之间通过事件进行通信，避免直接引用对方。</li></ol><p>总的来说，避免 JavaScript 文件相互引用时的常见问题，需要注意模块之间的依赖关系、加载顺序以及合理设计模块之间的通信机制。通过合理的代码组织和模块化设计，可以有效减少相互引用带来的问题，并确保代码的可维护性和可扩展性。</p><h3 id="_2-4-commonjs-和-es-module-的区别" tabindex="-1">2.4 CommonJS 和 ES Module 的区别 <a class="header-anchor" href="#_2-4-commonjs-和-es-module-的区别" aria-label="Permalink to &quot;2.4 CommonJS 和 ES Module 的区别&quot;">​</a></h3><h3 id="_2-5-settimeout-和-setinterval-的区别" tabindex="-1">2.5 setTimeout 和 setInterval 的区别 <a class="header-anchor" href="#_2-5-settimeout-和-setinterval-的区别" aria-label="Permalink to &quot;2.5 setTimeout 和 setInterval 的区别&quot;">​</a></h3><h3 id="_2-6-for-in-和-for-of-的区别" tabindex="-1">2.6 for...in 和 for...of 的区别 <a class="header-anchor" href="#_2-6-for-in-和-for-of-的区别" aria-label="Permalink to &quot;2.6 for...in 和 for...of 的区别&quot;">​</a></h3><h3 id="_2-7-深拷贝和浅拷贝的区别" tabindex="-1">2.7 深拷贝和浅拷贝的区别 <a class="header-anchor" href="#_2-7-深拷贝和浅拷贝的区别" aria-label="Permalink to &quot;2.7 深拷贝和浅拷贝的区别&quot;">​</a></h3><h3 id="_2-8-object-prototype-tostring-call" tabindex="-1">2.8 Object.prototype.toString.call <a class="header-anchor" href="#_2-8-object-prototype-tostring-call" aria-label="Permalink to &quot;2.8 Object.prototype.toString.call&quot;">​</a></h3><h3 id="_2-9-javascript-数值精度问题" tabindex="-1">2.9 JavaScript 数值精度问题 <a class="header-anchor" href="#_2-9-javascript-数值精度问题" aria-label="Permalink to &quot;2.9 JavaScript 数值精度问题&quot;">​</a></h3><p>在 JavaScript中，由于浮点数的表示方式（基于IEEE 754 标准），我们有时会遇到数值精度问题。这些问题主要源于<strong>二进制浮点数的表示限制，导致无法精确表示所有的十进制小数</strong>。</p><p>以下是一些解决 JavaScript 数值精度问题的方法：</p><ol><li><strong>toFixed() 方法</strong>： <ul><li>当你需要将浮点数转换为字符串并保留一定的小数位数时，可以使用 <code>toFixed()</code> 方法。但请注意，<code>toFixed()</code> 返回的是一个字符串，而不是一个数字。</li></ul></li><li><strong>Math.round(), Math.floor(), Math.ceil()</strong>： <ul><li>这些函数可以帮助你四舍五入、向下取整或向上取整到最接近的整数。</li></ul></li><li><strong>使用第三方库</strong>： <ul><li>有些第三方库，如 <code>decimal.js</code> 或 <code>bignumber.js</code>，提供了高精度的十进制数运算。这些库可以处理比JavaScript内置Number类型更大或更精确的数值。</li></ul></li></ol><p>在处理金融或需要高精度计算的场景时，使用第三方库（如 <code>decimal.js</code> 或 <code>bignumber.js</code>）通常是一个好主意，因为它们提供了比JavaScript内置Number类型更高的精度和可靠性。</p><h3 id="_2-10-事件-level0、level1" tabindex="-1">2.10 事件 level0、level1 <a class="header-anchor" href="#_2-10-事件-level0、level1" aria-label="Permalink to &quot;2.10 事件 level0、level1&quot;">​</a></h3><p>在HTML中，<code>level0</code>和<code>level1</code>并不是标准的事件处理术语。然而，我们可以讨论HTML中的事件处理机制，以及如何在不同层级（如元素层级）上添加事件。</p><ol><li><p>基本的 HTML 事件处理（类似于 “level0”）</p><p>在HTML中，你可以直接在元素标签内使用<code>on&lt;event&gt;</code>属性来添加事件监听器。例如：</p><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">onclick</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#82AAFF;">alert</span><span style="color:#C3E88D;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Button clicked!</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">)</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Click Me</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li><li><p>使用 JavaScript 添加事件监听器（类似于 “level1” 或更高级别）</p><p>为了更灵活和可维护的代码，通常建议使用JavaScript来添加事件监听器。这可以通过<code>addEventListener</code>方法来实现。</p><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;!</span><span style="color:#F07178;">DOCTYPE</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">html</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">html</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">lang</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">en</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">head</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">meta</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">charset</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">UTF-8</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">meta</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">name</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">viewport</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">content</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">width=device-width, initial-scale=1.0</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">title</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Event Handling Example</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">title</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">head</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">body</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">id</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">myButton</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Click Me</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#89DDFF;">  &lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 获取按钮元素  </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> button </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">myButton</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 添加点击事件监听器  </span></span>
<span class="line"><span style="color:#A6ACCD;">    button</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">addEventListener</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">click</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;">  </span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#82AAFF;">alert</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Button clicked via addEventListener!</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;">  </span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;  </span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">body</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">html</span><span style="color:#89DDFF;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div></li><li><p>层级概念</p><p>在 HTML 和 JavaScript 中，事件可以在不同的层级上被捕获和处理。这通常涉及事件冒泡（event bubbling）和事件捕获（event capturing）的概念。</p><ul><li><strong>事件冒泡</strong>：事件从触发它的最内层元素（目标元素）开始，然后向外层元素传播，直到到达文档的根元素（通常是<code>document</code>对象）。</li><li><strong>事件捕获</strong>：与事件冒泡相反，事件从文档的根元素开始，然后向目标元素传播，直到到达目标元素本身。</li></ul><p>在大多数情况下，你会使用事件冒泡，因为它更符合直觉，并且更容易管理。但是，在某些情况下，你可能需要使用事件捕获来阻止事件冒泡或实现特定的交互逻辑。</p></li><li><p>level0、level1 对比</p><p>虽然 “level0” 和 “level1” 不是 HTML 或 JavaScript 中的标准术语，但你可以理解它们为不同级别的事件处理方式。基本的 HTML 事件处理（如<code>onclick</code> 属性）可以看作是较低级别的方式，而使用 JavaScript 的 <code>addEventListener</code> 方法则提供了更高级别、更灵活的事件处理机制。</p></li><li><p>场景</p><p>在HTML和JavaScript中，如果一个元素同时被添加了两种事件处理器（例如，通过HTML属性如<code>onclick</code>和通过JavaScript的<code>addEventListener</code>方法），那么事件的触发顺序通常遵循以下规则：</p><ul><li><strong>HTML属性事件处理器（如<code>onclick</code>）</strong>：这些事件处理器是在元素标记中直接定义的，它们通常会在JavaScript添加的事件监听器之前被触发。这是因为这些事件处理器是在元素解析和构建DOM时就已经存在的，而JavaScript添加的事件监听器则是在页面加载和JavaScript执行时才被添加到DOM中的。</li><li><strong>JavaScript添加的事件监听器（<code>addEventListener</code>）</strong>：这些事件监听器是通过JavaScript代码动态添加到元素上的。它们会在HTML属性事件处理器之后被触发。这是因为<code>addEventListener</code>方法允许更精细的控制，包括指定事件是否在捕获阶段触发，以及添加多个事件监听器而不会相互覆盖。</li></ul><p>然而，需要注意的是，这种触发顺序并不是绝对的，因为它可能受到多种因素的影响，包括浏览器的实现细节、JavaScript代码的执行时机和顺序等。在某些情况下，如果JavaScript代码在页面加载的非常早期就执行了（例如，在<code>&lt;head&gt;</code>标签中或通过<code>DOMContentLoaded</code>事件），并且添加了事件监听器，那么这些监听器可能会在页面完全解析和构建DOM之前就已经存在，从而可能改变事件的触发顺序。</p><p>此外，如果使用了事件委托（即在父元素上监听事件，然后根据事件的目标元素来执行相应的操作），那么事件的触发顺序也会受到影响，因为事件是在父元素上捕获的，然后根据需要冒泡到目标元素或停止传播。</p><p>总的来说，为了确保事件的正确处理和触发顺序，建议避免在同一个元素上同时使用HTML属性事件处理器和JavaScript添加的事件监听器。相反，应该选择其中一种方法，并保持一致的事件处理策略。这样可以减少潜在的冲突和不确定性，使代码更加清晰和可维护。</p></li></ol>`,65),p=[o];function t(r,c,i,D,y,F){return n(),s("div",null,p)}const C=a(e,[["render",t]]);export{u as __pageData,C as default};
