import{_ as i,c as l,o as e,V as a}from"./chunks/framework.35c8bad0.js";const m=JSON.parse('{"title":"面试题[性能优化]","description":"","frontmatter":{"title":"面试题[性能优化]","date":"2023-06-07T00:00:00.000Z"},"headers":[],"relativePath":"blog/interview/230607.md","lastUpdated":1712977464000}'),o={name:"blog/interview/230607.md"},t=a('<h1 id="面试题-性能优化" tabindex="-1">面试题[性能优化] <a class="header-anchor" href="#面试题-性能优化" aria-label="Permalink to &quot;面试题[性能优化]&quot;">​</a></h1><div class="info custom-block"><p class="custom-block-title">INFO</p><p>在实际的业务场景下...</p></div><h2 id="_1-前端性能优化思路" tabindex="-1">1. 前端性能优化思路 <a class="header-anchor" href="#_1-前端性能优化思路" aria-label="Permalink to &quot;1. 前端性能优化思路&quot;">​</a></h2><h2 id="_2-什么情况下会重绘和回流-常见的改善方案" tabindex="-1">2. 什么情况下会重绘和回流，常见的改善方案 <a class="header-anchor" href="#_2-什么情况下会重绘和回流-常见的改善方案" aria-label="Permalink to &quot;2. 什么情况下会重绘和回流，常见的改善方案&quot;">​</a></h2><p>浏览器请求到对应页面资源的时候，会将 HTML 解析成 DOM，把 CSS 解析成 CSSDOM，然后将 DOM 和 CSSDOM 合并就产生了 Render Tree。在有了渲染树之后，浏览器会根据流式布局模型来计算它们在页面上的大小和位置，最后将节点绘制在页面上。</p><p>那么当 Render Tree 中部分或全部元素的尺寸、结构、或某些属性发生改变，浏览器就会重新渲染页面，这个就是浏览器的回流。常见的回流操作有：页面的首次渲染、浏览器窗口尺寸改变、部分元素尺寸或位置变化、添加或删除可见的 DOM、激活伪类、查询某些属性或调用方法（各种宽高的获取，滚动方法的执行等）。</p><p>当页面中元素样式的改变不影响它在文档流的位置时（如颜色、背景等），这个就是重绘。</p><p><em><strong>回流必将导致重绘，重绘不一定会引起回流。回流比重绘的代价更高。</strong></em></p><p>常见的改善方案：</p><ul><li>避免频繁操作 DOM，可以利用 DocumentFragment，来进行对应的 DOM 操作，将最后的结果添加到文档中。</li><li>在进行频繁操作的时候，使用节流和防抖来控制调用频率。</li><li>灵活使用 display: none 属性，操作结束后将其显示出来，因为 display 的属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘。</li><li>获取各种会引起重绘/回流的属性，尽量将其缓存起来，不要频繁的去获取。</li><li>使用 CSS3 动画代替 JavaScript 动画：CSS3 动画会触发 GPU 加速，性能更好。</li><li>对复杂动画采用绝对定位，使其脱离文档流，否则它会频繁的引起父元素及其后续元素的回流。</li></ul><h2 id="_3-动画优化" tabindex="-1">3. 动画优化 <a class="header-anchor" href="#_3-动画优化" aria-label="Permalink to &quot;3. 动画优化&quot;">​</a></h2><p>一般情况下，动画需要频繁的操作 DOM，就会导致页面的性能问题，我们可以对复杂的动画采用<strong>绝对定位</strong>（position 属性设置为 absolute 或者 fixed），使其脱离文档流，这样它的回流就不会影响到页面其它元素了。</p><h2 id="_4-图片优化" tabindex="-1">4. 图片优化 <a class="header-anchor" href="#_4-图片优化" aria-label="Permalink to &quot;4. 图片优化&quot;">​</a></h2><p>图片优化是一种常见的性能优化策略，旨在减少网页加载时间和带宽占用。通过减少图片的体积，可以加快图片加载速度，提升用户体验，并节省用户流量。以下是一些具体的图片优化方法：</p><ol><li>压缩图片： 使用图片压缩工具（如TinyPNG、ImageOptim等）可以无损或有损地减小图片的文件大小。有损压缩会略微降低图片的质量，但可以显著减小文件大小。无损压缩会保持图片质量不变，但压缩率较有损压缩低。</li><li>选择适当的图片格式： 对于不同类型的图片，选择合适的图片格式可以带来更好的优化效果。一般情况下： <ul><li>使用 JPEG 格式对于包含丰富颜色和复杂细节的照片效果较好。</li><li>使用 PNG 格式对于图标、透明背景和简单图形效果较好。</li><li>使用 WebP 格式（现代浏览器支持）可以在保持图片质量的同时大幅减小文件大小。</li></ul></li><li>适当调整图片尺寸： 将图片调整为网页上实际显示的尺寸大小，避免加载过大的图片。通过在 HTML 或 CSS 中指定图片的宽高，可以确保浏览器不会拉伸图片，从而减少不必要的下载。</li><li>使用图像矢量化： 对于简单的图形和图标，可以使用 SVG（矢量图形）代替位图图片。SVG 是基于 XML 的矢量图形格式，它可以无损缩放而不失真，且文件大小较小。</li><li>懒加载： 对于页面上位于可视区域之外的图片，可以延迟加载，直到用户滚动到它们的位置。懒加载可以减少页面初次加载的图片数量，优化初始加载速度。</li><li>响应式图片： 使用响应式图片可以根据不同的设备和屏幕尺寸加载不同尺寸的图片，避免加载过大的图片。</li><li>HTTP 缓存： 使用适当的 HTTP 缓存策略，使浏览器能够缓存图片，减少重复的下载请求。</li><li>使用图像 CDN：使用图像 CDN（内容分发网络）来加速图片加载和交付，提供快速的全球访问能力。</li></ol><h2 id="_5-什么是渐进式图像加载-progressive-image-loading-它如何改善网页加载性能" tabindex="-1">5. 什么是渐进式图像加载（Progressive Image Loading）？它如何改善网页加载性能？ <a class="header-anchor" href="#_5-什么是渐进式图像加载-progressive-image-loading-它如何改善网页加载性能" aria-label="Permalink to &quot;5. 什么是渐进式图像加载（Progressive Image Loading）？它如何改善网页加载性能？&quot;">​</a></h2><h2 id="_6-在实际的业务场景下怎么运用缓存机制" tabindex="-1">6. 在实际的业务场景下怎么运用缓存机制 <a class="header-anchor" href="#_6-在实际的业务场景下怎么运用缓存机制" aria-label="Permalink to &quot;6. 在实际的业务场景下怎么运用缓存机制&quot;">​</a></h2><p>在实际的业务场景中，合理运用缓存机制可以提升网站的性能、减少网络请求、降低服务器负载，并提供更好的用户体验。以下是一些常见的应用场景和相应的缓存策略：</p><ol><li>静态资源缓存：对于网站的静态资源（如 CSS、JavaScript 文件、图像等），可以通过设置适当的缓存头来让浏览器缓存这些资源。使用 Cache-Control 和 Expires 字段设置较长的缓存时间，使客户端在下次访问时可以直接从缓存获取资源。</li><li>页面级缓存：对于某些不频繁变化的页面（如首页、文章详情页等），可以在服务器端设置缓存策略，使这些页面在一定时间内不会重复生成，而是直接返回缓存的 HTML。可以使用 HTTP 头部字段如 Cache-Control、Expires 和 Last-Modified 来控制页面的缓存时间和验证机制。</li><li>数据接口缓存：对于频繁被访问的数据接口，可以将其结果缓存起来，以减少数据库查询或复杂计算的次数。可以使用内存缓存、分布式缓存或缓存服务器（如 Redis）来存储这些结果，并设置合适的缓存时间或失效策略。</li><li>动态内容缓存：对于一些动态生成的内容，可以使用缓存来提高性能。例如，可以将部分页面片段或动态生成的 HTML 片段缓存起来，以减少服务器端的计算和数据库查询。可以使用类似 Fragment Caching 或缓存模板片段的技术来实现。</li><li>CDN 缓存：将静态资源部署到 CDN（内容分发网络）上，并配置合适的缓存策略，可以使这些资源更快地被用户访问，并减轻源服务器的负载。CDN 提供了全球分布的节点，能够将静态资源缓存到离用户更近的位置，提供更快的访问速度。</li></ol><p>在运用缓存机制时，需要根据具体业务需求和资源特性来选择合适的缓存策略，并进行测试和性能优化。需要注意的是，缓存可能导致数据不一致性的问题，因此在更新或修改缓存的数据时，需要及时更新缓存或采用合适的缓存失效策略，以保证数据的一致性和准确性。</p><h2 id="_7-用户反馈打开页面白屏时间很长-页面操作很卡-如何优化" tabindex="-1">7. 用户反馈打开页面白屏时间很长，页面操作很卡，如何优化 <a class="header-anchor" href="#_7-用户反馈打开页面白屏时间很长-页面操作很卡-如何优化" aria-label="Permalink to &quot;7. 用户反馈打开页面白屏时间很长，页面操作很卡，如何优化&quot;">​</a></h2><p>采取以下措施进行优化：</p><ol><li>页面加载优化：针对页面加载速度过慢的问题，可以采用以下方法进行优化： <ul><li>压缩和合并脚本和样式表</li><li>减少 HTTP 请求，使用 CDN 加速</li><li>使用流式加载，延迟加载图片和脚本</li><li>优化图片大小和格式，使用 WebP 等格式</li></ul></li><li>代码优化：为了提高页面性能，可以进行以下代码优化： <ul><li>删除无用的代码和文件</li><li>将多个请求合并为一个请求</li><li>避免过多的重绘和回流</li><li>使用 Web Worker 进行异步操作</li><li>避免使用过多的全局变量和 DOM 操作</li></ul></li><li>数据优化：为了提高页面响应速度和性能，可以进行以下数据优化： <ul><li>使用缓存技术，尽量减少请求服务器</li><li>对数据进行分页处理，避免一次性加载大量数据</li><li>对数据进行压缩和加密，减少传输时间</li></ul></li><li>测试和监测：对于页面性能进行测试和监测，可以采用以下工具： <ul><li>Chrome 开发者工具</li><li>PageSpeed Insights</li><li>GTmetrix</li><li>WebPagetest</li><li>Pingdom</li></ul></li></ol><h2 id="_8-什么是网页性能监测和分析-可以使用哪些工具来监测和分析网页性能" tabindex="-1">8. 什么是网页性能监测和分析？可以使用哪些工具来监测和分析网页性能？ <a class="header-anchor" href="#_8-什么是网页性能监测和分析-可以使用哪些工具来监测和分析网页性能" aria-label="Permalink to &quot;8. 什么是网页性能监测和分析？可以使用哪些工具来监测和分析网页性能？&quot;">​</a></h2><h2 id="_9-vue-或-react-有哪些性能优化方式-请结合项目说明" tabindex="-1">9. Vue（或 React）有哪些性能优化方式，请结合项目说明 <a class="header-anchor" href="#_9-vue-或-react-有哪些性能优化方式-请结合项目说明" aria-label="Permalink to &quot;9. Vue（或 React）有哪些性能优化方式，请结合项目说明&quot;">​</a></h2><ol><li>懒加载组件：在大型项目中，可以将页面分割成多个小模块，然后使用懒加载的方式，按需加载对应的模块。这样可以减少初始加载时的资源压力。</li><li>虚拟列表：对于长列表或表格数据，可以使用虚拟列表技术，只渲染当前可见区域的内容，而不是全部渲染，从而减少渲染开销。</li><li>避免不必要的渲染：使用 useEffect Hook、shouldComponentUpdate 或 Vue 的 watch 等方式，避免不必要的组件渲染，提高渲染效率。</li><li>代码拆分：将业务逻辑和组件进行拆分，按需引入，减少不必要的代码加载和执行。</li><li>使用 CDN 加速：将一些常用的库、框架等资源通过 CDN 加载，可以提高加载速度，减轻服务器压力。</li></ol><p>举例说明： 假设在一个 Vue 项目中，有一个页面包含了一个较大的列表，可以通过虚拟列表技术来进行优化。首先，在组件中使用 Vue 的虚拟列表组件（比如 vue-virtual-scroller），根据当前滚动位置动态渲染可见区域的列表项，而不是一次性渲染所有列表项。这样可以显著减少页面渲染时的开销，提升页面加载和滚动的性能。</p><p>另外，如果列表中的每个项都是一个复杂的组件，还可以结合 useEffect Hook、shouldComponentUpdate 或 Vue 的 watch 来避免不必要的组件渲染，进一步提高性能。</p>',28),r=[t];function n(s,d,h,c,p,u){return e(),l("div",null,r)}const b=i(o,[["render",n]]);export{m as __pageData,b as default};
