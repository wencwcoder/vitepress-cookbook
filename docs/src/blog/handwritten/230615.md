---
title: 手写题[JavaScript][算法题]
date: 2023-06-15
---

# 手写题[JavaScript][算法题]



## 1. 数组（Array）

### 1.1 三数之和

三数之和（3Sum）是一个经典的算法问题，要求在给定数组中找到所有不重复的三元组，使得三个数的和为0。

下面是一个 JavaScript 的实现示例：

```javascript
function threeSum(nums) {
  let result = [];
  nums.sort((a, b) => a - b); // 先对数组进行排序

  for (let i = 0; i < nums.length - 2; i++) {
    if (i === 0 || (i > 0 && nums[i] !== nums[i - 1])) {
      let left = i + 1;
      let right = nums.length - 1;
      let target = 0 - nums[i];

      while (left < right) {
        if (nums[left] + nums[right] === target) {
          result.push([nums[i], nums[left], nums[right]]);
          while (left < right && nums[left] === nums[left + 1]) left++;
          while (left < right && nums[right] === nums[right - 1]) right--;
          left++;
          right--;
        } else if (nums[left] + nums[right] < target) {
          left++;
        } else {
          right--;
        }
      }
    }
  }
  return result;
}

// 示例
const nums = [-1, 0, 1, 2, -1, -4];
console.log(threeSum(nums));
```

在这个实现中，我们首先对数组进行排序，然后使用双指针的方法来寻找三数之和为0的三元组。遍历数组，对于每一个数字，设定一个目标值，然后在剩余的部分使用双指针来找到满足条件的组合。

这样的实现能够在 O(n^2) 的时间复杂度内解决这个问题。



### 1.2 两数之和





### 1.3 比较版本号

当我们谈论比较版本号时，通常是指在软件开发中对软件版本进行比较。软件版本号是用来标识软件发布的不同版本的一种方式，通常采用数字和点号（.）组合而成的字符串表示。

一般来说，版本号的格式遵循主版本号.次版本号.修订版本号的形式，例如：1.2.3。

- 主版本号：一般表示软件的重大更新或功能的重大改变，通常当软件有重大功能新增或变化时会增加主版本号。
- 次版本号：表示软件的较小更新，可能包含了一些新的功能、改进或修复了一些bug。
- 修订版本号：表示软件的修复版本，通常用于修复已知的bug或安全漏洞。

在比较版本号时，我们按照如下规则进行比较：

1. 首先比较主版本号，主版本号较大的版本被认为是更新的版本。
2. 如果主版本号相同，则比较次版本号，次版本号较大的版本被认为是更新的版本。
3. 如果主版本号和次版本号都相同，则比较修订版本号，修订版本号较大的版本被认为是更新的版本。

通过这种方式，我们可以确定哪个版本号是较新的，或者两个版本号是否相同。

```javascript
// 如果 version1 > version2 返回 1，如果 version1 < version2 返回 -1，除此之外返回 0
function compareVersions(version1, version2) {
  const v1 = version1.split('.');
  const v2 = version2.split('.');
  // 比较两个数组的长度，得到最大的数组长度
  const maxLength = Math.max(v1.length, v2.length);
  // 遍历数组，分别比较同一个位置上的版本号
  for (let i = 0; i < maxLength; i++) {
    //  忽略前导0，使用 parseInt() 转为数字
    const num1 = parseInt(v1[i] || 0);
    const num2 = parseInt(v2[i] || 0);
    if (num1 > num2) {
      return 1;
    } else if (num1 < num2) {
      return -1;
    }
  }
  return 0;
};

// 示例
const version1 = "1.2.3";
const version2 = "1.2.4";
console.log(compareVersions(version1, version2)); // 输出: -1
```



### 1.4 冒泡排序





### 1.5 快速排序





## 2. 树（Tree）

### 2.1 反转二叉树





## 3. 栈（Stack）

### 3.1 有效括号匹配

有效括号匹配是指一个字符串中的括号是否能够完全匹配，即每个左括号都有相应的右括号与之匹配，并且括号之间的嵌套关系必须正确。

一种常见的解决方案是使用栈来实现。遍历字符串中的每个字符，当遇到左括号时，将其压入栈中；当遇到右括号时，检查栈顶元素是否为对应的左括号，如果是，则将栈顶元素弹出，继续遍历；如果不是，则说明括号不匹配，返回 false。最后，如果栈为空，则说明所有括号都匹配，返回 true；否则返回 false。

下面是一个 JavaScript 的实现示例：

```javascript
function isValid(s) {
  const stack = [];
  const mapping = {
    ')': '(',
    ']': '[',
    '}': '{'
  };
  
  for (let char of s) {
    if (char in mapping) {
      const topElement = stack.pop() || '#';
      if (mapping[char] !== topElement) {
        return false;
      }
    } else {
      stack.push(char);
    }
  }
  
  return stack.length === 0;
}

// 示例
console.log(isValid("()"));       // true
console.log(isValid("()[]{}"));   // true
console.log(isValid("(]"));       // false
console.log(isValid("([)]"));     // false
console.log(isValid("{[]}"));     // true
```



## 4. 队列（Queue）





## 5. 链表（Linked List）

### 5.1 链式调用

题目：提供了一个数组结构的 data，要求实现一个 `query` 方法，返回一个新的数组，query 方法内部有 `过滤`、`排序`、`分组` 等操作，并且支持链式调用，调用最终的 `execute` 方法返回结果。



### 5.2 判断链表有环

在 JavaScript 中，要判断一个链表是否有环，可以使用一种称为“快慢指针”（也称为龟兔赛跑算法）的技术。这种方法通过两个指针以不同的速度遍历链表来检测环的存在。

具体步骤如下：

1. 初始化两个指针：
   - `slow` 指针每次移动一步。
   - `fast` 指针每次移动两步。
2. 遍历链表：
   - 同时移动 `slow` 和 `fast` 指针，直到它们相遇或 `fast` 指针到达链表的末尾。
3. 判断结果：
   - 如果 `slow` 和 `fast` 指针相遇，则链表中存在环。
   - 如果 `fast` 指针到达链表的末尾（即 `fast` 或 `fast.next` 为 `null`），则链表中没有环。

以下是使用JavaScript实现这一算法的示例代码：

```javascript
class ListNode {
  constructor(value = 0, next = null) {
    this.value = value;
    this.next = next;
  }
}

function hasCycle(head) {
  if (!head || !head.next) {
    // 空链表或只有一个节点的链表不可能有环
    return false;
  }

  let slow = head;
  let fast = head.next;

  while (slow !== fast) {
    // 如果快指针到达链表末尾，则没有环
    if (!fast || !fast.next) {
      return false;
    }
    // 慢指针移动一步
    slow = slow.next;
    // 快指针移动两步
    fast = fast.next.next;
  }

  // 慢指针和快指针相遇，说明有环
  return true;
}

// 示例用法
let node1 = new ListNode(1);
let node2 = new ListNode(2);
let node3 = new ListNode(3);
let node4 = new ListNode(4);

node1.next = node2;
node2.next = node3;
node3.next = node4;
// 创建一个环
node4.next = node2;

console.log(hasCycle(node1)); // 输出: true
```

在上面的示例中，我们创建了一个带有环的链表，并调用了 `hasCycle` 函数来检测环的存在。函数返回 `true`，表示链表中确实有环。

请注意，这种方法的时间复杂度为 O(n)，其中 n 是链表中的节点数，因为两个指针最多遍历整个链表一次。空间复杂度为 O(1)，因为我们只使用了有限数量的额外变量（两个指针）。



