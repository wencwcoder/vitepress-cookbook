---
title: 面试题[JavaScript]
date: 2023-05-24
---

# 面试题[JavaScript]



## 1. JavaScript 基础知识

### 1.1 数据类型

JavaScript 中将数据类型分为基本数据类型和引用数据类型，它们其中有一个区别就是存储的位置不同。

基本数据类型：boolean、string、number、undefined、null、symbol、bigint。

引用数据类型：array、object。



### 1.2 typeof 和 instanceof 的区别

instanceof 原理手写



### 1.3 typeof null 的结果是什么？为什么？

在 JavaScript 中，`typeof null` 的结果是 `"object"`。这是一个历史遗留问题，而不是出于设计上的考虑。

在 JavaScript 中，所有事物都是对象，但有一个例外：`null`。然而，为了简化类型检测，`typeof` 操作符对于原始数据类型（如 `number`、`string`、`boolean`）返回的是它们的小写形式字符串（如  `"number"`、`"string"`、`"boolean"`），但对于复杂的数据类型（如对象和函数），它返回的是 `"object"`。

原因可以追溯到 JavaScript 的早期版本，特别是 ECMAScript 3 和更早的版本。在 JavaScript 最初的实现中，JavaScript 中的值是由一个**表示类型的标签和实际数据值**表示的。对象的类型标签是 0。由于 `null` 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，`typeof null` 也因此返回 `"object"`。（[参考来源 (opens new window)](https://www.2ality.com/2013/10/typeof-null.html)）

曾有一个 ECMAScript 的修复提案（通过选择性加入的方式），但[被拒绝了 (opens new window)](http://wiki.ecmascript.org/doku.php?id=harmony:typeof_null)。该提案会导致 `typeof null === "null"`。



### 1.4 字符串的常用方法





### 1.5 数组的常用方法

```javascript
// 判断变量是否是数组
Array.isArray(arr)
arr instanceof Array
Object.prototype.toString.call(arr) === '[object Array]'
```



### 1.6 对象的常用方法





### 1.7 什么是可迭代对象

**可迭代对象是一个允许你对其元素进行遍历的对象**。

在 JavaScript 中，可迭代对象（iterable）是一个实现了迭代协议的对象，允许你在对象上创建迭代器（iterator）。迭代器是一个实现了迭代器协议的对象，它保持了对集合中每个元素的跟踪，并记住遍历的位置。

可迭代对象：一个对象要实现可迭代协议，必须实现一个特殊的方法 `@@iterator()`，这个方法在对象上调用时会返回一个迭代器。在大多数情况下，你会通过调用对象的 `Symbol.iterator` 方法（`[Symbol.iterator]()`）来获取迭代器，但更常见的是使用扩展运算符（`...`）、`for...of` 循环或 `Array.from()` 等内置功能来自动处理迭代。

迭代器：迭代器必须实现一个迭代器协议，这个协议定义了一个对象的 `next()` 方法，该方法返回一个对象，该对象具有两个属性：`value` 和 `done`。`value` 属性表示迭代器返回的当前元素的值，`done` 属性是一个布尔值，当迭代器遍历完所有元素时，它为 `true`。

常见的可迭代对象：

- **数组**（Array）：数组是可迭代对象，因为它们实现了 `@@iterator()` 方法。
- **字符串**（String）：字符串也是可迭代对象，可以按字符迭代。
- **Map 和 Set**：ES6 引入的 `Map` 和 `Set` 对象也是可迭代对象。
- **arguments 对象**：函数中的 `arguments` 对象是可迭代的。
- **NodeList**：在DOM操作中，`NodeList` 对象（例如，通过 `document.querySelectorAll` 获取的节点列表）通常是可迭代的（尽管这取决于具体的浏览器实现）。

使用示例：

```javascript
// 数组是可迭代的
const arr = [1, 2, 3];
for (const value of arr) {
  console.log(value); // 输出 1, 2, 3
}

// 字符串是可迭代的
const str = 'hello';
for (const char of str) {
  console.log(char); // 输出 'h', 'e', 'l', 'l', 'o'
}

// 自定义可迭代对象
const iterable = {
  0: 'a',
  1: 'b',
  2: 'c',
  length: 3,
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.length) {
          return { value: this[index++], done: false };
        } else {
          return { done: true };
        }
      }
    };
  }
};
for (const value of iterable) {
  console.log(value); // 输出 'a', 'b', 'c'
}
```



### 1.8 什么是类数组

类数组（Array-like）指的是**具有类似数组结构的对象**。

1. 定义与特性

   - **定义**：类数组是一个对象，它拥有length属性，并且其属性名通常为非负整数。这使得它在外观上类似于数组，但实际上并不是数组。
   - **特性**：
     - **length属性**：类数组对象通常具有一个length属性，用于表示对象中元素的个数。
     - **索引访问**：可以通过索引值从类数组对象中获取元素，就像访问数组元素一样。
     - **无数组方法**：尽管类数组对象具有length属性和可以通过索引访问元素，但它们并不具备数组原型上的方法（如push、pop、forEach等）。因此，无法直接使用这些方法对类数组对象进行操作。

2. 常见类数组对象

   - **arguments对象**：在JavaScript函数内部自动创建的对象，用于存储函数调用时传递的参数。它是一个类数组对象，可以通过索引访问参数，并具有length属性。
   - **HTMLCollection和NodeList**：DOM操作返回的一些对象，如document.getElementsByTagName()返回的对象集合，也是类数组对象。
   - **字符串**：在JavaScript中，字符串也可以被视为类数组对象，因为可以通过索引访问每个字符，并具有length属性。但需要注意的是，字符串本身并不是数组。

3. 类数组与数组的区别

   - **原型链**：类数组的原型关系与数组不同，因此无法直接调用数组的方法。而数组则继承自Array.prototype，可以使用数组的所有方法。
   - **类型**：类数组本质上是对象，而数组则是一种特殊的数据结构。

4. 类数组转换为数组

   由于类数组对象无法直接使用数组的方法，因此有时需要将其转换为真正的数组。在JavaScript中，可以使用以下方法将类数组对象转换为数组：

   - **`Array.from()`方法**：这是一个静态方法，它接受一个类数组对象或可迭代对象，并返回一个新的数组实例。

     ```javascript
     const arrayLike = {0: 'a', 1: 'b', length: 2};
     const array = Array.from(arrayLike);
     console.log(array); // ['a', 'b']
     ```

   - **扩展运算符（`...`）**：在ES6中，扩展运算符可以用于将类数组对象或可迭代对象展开为数组元素。

     ```javascript
     const arrayLike = {0: 'a', 1: 'b', length: 2};
     const array = [...arrayLike];
     console.log(array); // ['a', 'b']
     ```

   - **`Array.prototype.slice.call()`方法**：在ES6之前，这种方法常用于将类数组对象转换为数组。它利用了`Array.prototype.slice`方法，该方法可以接受一个类数组对象作为上下文（`this`值），并返回一个新的数组。

     ```javascript
     const arrayLike = {0: 'a', 1: 'b', length: 2};
     const array = Array.prototype.slice.call(arrayLike);
     console.log(array); // ['a', 'b']
     ```



### 1.9 变量提升





### 1.10 闭包和作用域

::: details 闭包定义
根据 JavaScript 中的词法作用域规则，内部函数总是可以访问其外部函数中声明的变量。当内部函数被返回到外部函数之外时，即使外部函数执行结束了，但是内部函数引用了外部函数的变量，这些变量仍然会被保存在内存中。这个现象称为闭包。
:::

JavaScript 中常见的作用域包括全局作用域、函数作用域、块级作用域。

JavaScript 中自由变量的查找是在**函数定义**的地方，向上级作用域查找，不是在执行的地方。 

闭包是作用域应用的特殊场景。常见的闭包使用有两种场景：一种是函数作为参数被传递；一种是函数作为返回值被返回。

怎么看待闭包的副作用？



### 1.11 原型和原型链





### 1.12 JavaScript 执行上下文、执行栈和闭包





### 1.13 对 this 的理解





### 1.14 new 操作符做了什么





### 1.15 继承

[JavaScript实现继承](/frontend/javascript/240610.md)



### 1.16 事件模型

事件冒泡（Event Bubbling）、事件捕获（Event Capturing）、事件委托（Event Delegation）。



### 1.17 事件循环

[JavaScript事件循环机制](/frontend/javascript/240529.md)



### 1.18 JavaScript 中的异步编程

在 JavaScript 中，异步编程是一项非常核心且重要的技能，它允许程序在等待某些操作（如网络请求、文件读取或定时器等）完成时，继续执行其他任务，从而提高应用程序的响应性和性能。以下是 JavaScript 中处理异步编程的几种主要方法：

1. 回调函数（Callbacks）

   回调函数是最基本的异步编程技术。你可以将一个函数作为参数传递给另一个函数，并在异步操作完成时调用这个回调函数。

   ```javascript
   function fetchData(callback) {
     setTimeout(() => {
       const data = "Hello, World!";
       callback(data);
     }, 1000);
   }
   
   fetchData((data) => {
     console.log(data);
   });
   ```

2. Promise

   Promise 是一种更强大和灵活的异步编程模式，用于处理更复杂的异步操作链。一个 Promise 对象表示一个最终可能完成（并得到一个结果值）或失败（并得到一个原因）的异步操作。

   ```javascript
   function fetchData() {
     return new Promise((resolve, reject) => {
       setTimeout(() => {
         const success = true;
         if (success) {
           resolve("Hello, World!");
         } else {
           reject("Error fetching data");
         }
       }, 1000);
     });
   }
   
   fetchData()
     .then((data) => {
       console.log(data);
     })
     .catch((error) => {
       console.error(error);
     });
   ```

3. async/await

   `async` 和 `await` 是基于 Promise 的语法糖，使得异步代码看起来更像同步代码，增强了可读性和可维护性。`async` 函数返回一个 Promise，而 `await` 表达式用于等待 Promise 完成，并返回 Promise 的结果。

   ```javascript
   function fetchData() {
     return new Promise((resolve, reject) => {
       setTimeout(() => {
         const success = true;
         if (success) {
           resolve("Hello, World!");
         } else {
           reject("Error fetching data");
         }
       }, 1000);
     });
   }
   
   async function getData() {
     try {
       const data = await fetchData();
       console.log(data);
     } catch (error) {
       console.error(error);
     }
   }
   
   getData();
   ```

4. 事件循环（Event Loop）

   [JavaScript事件循环机制](/frontend/javascript/240529.md)

5. Generator 函数

   Generator 函数提供了一种更为复杂的方式来处理异步操作，但相对于 `async/await`，它们更不常用。Generator 函数可以暂停和恢复执行，使得可以在等待异步操作完成时返回控制权。

   ```javascript
   function* fetchDataGenerator() {
     const promise = new Promise((resolve, reject) => {
       setTimeout(() => {
         resolve("Hello, World!");
       }, 1000);
     });
     const data = yield promise;
     console.log(data);
   }
   
   const gen = fetchDataGenerator();
   
   gen.next().value.then((data) => {
     gen.next(data);
   });
   ```



## 2. JavaScript 拓展知识

### 2.1 ECMA 标准从提案到发布有几个阶段？哪个阶段是具有里程碑意义的


ECMA标准从提案到发布经历了以下几个阶段：

1. Stage 0 - Strawman（草案）：这个阶段是最初的提案阶段，通常由个人或小组提出，并还没有经过正式的标准化流程。提案可能只是一个想法或初步的概念。
2. Stage 1 - Proposal（提案）：在这个阶段，提案开始进入正式的标准化流程。提案需要详细说明其功能、语法和语义，并且需要提供示例代码和使用案例。
3. Stage 2 - Draft（草稿）：在这个阶段，提案转化为一份详细的草稿，其中包含了具体的语法规范和语义定义。草稿需要经过审查和讨论，并且需要有多个独立实现的证明。
4. Stage 3 - Candidate（候选）：在这个阶段，提案已经足够成熟，可以被视为候选标准。这意味着提案已经通过了实际应用并经过广泛的测试和实现。
5. Stage 4 - Finished（完成）：在这个阶段，提案被接受为最终的标准，已经准备好发布。提案的规范细节已经完善，并且已经有多个独立实现通过了所有测试。

这些阶段代表了ECMA标准的不同发展阶段，其中最具里程碑意义的是Stage 4 - Finished（完成）阶段。在这个阶段，提案被接受为最终的标准，意味着它已经经过了广泛的实现、测试和审查，并被认为是稳定和可靠的。完成阶段的标准可以被广泛采用和应用于实际的编程环境中。



### 2.2 JavaScript 中的严格模式



### 2.3 不创建新变量的前提下，如何交换两个变量的位置

- 解构赋值：适用于数组、对象和其他可迭代的数据结构。

```javascript
let a = 10;
let b = 20;
[a, b] = [b, a];
```

- 位运算符 -- 位异或（^）运算符：只适用于数字类型的变量。

```javascript
let a = 1;
let b = 2;
a = a ^ b;
b = a ^ b;
a = a ^ b;
```

- 加法和减法、乘法和除法：只适用于数字类型的变量。

```javascript
let a = 1;
let b = 2;

a = a + b;
b = a - b;
a = a - b;

a = a * b;
b = a / b;
a = a / b;
```



### 2.4 JavaScript 文件相互引用有什么问题

可能导致代码执行错误或者无法正常工作。下面是一些常见的问题及其解决方法：

1. **循环依赖（Circular Dependency）**： 循环依赖指的是两个或多个模块相互依赖，直接或间接地引用对方，导致模块无法正确加载。解决循环依赖问题的方法包括：
   - 重构代码结构，将共享的逻辑抽离到单独的模块中，避免直接相互引用。
   - 使用异步加载模块的方式，如 `import()` 动态导入语法，可以延迟加载模块，避免循环依赖问题。
2. **加载顺序错误**： 当 JavaScript 文件相互引用时，确保它们之间的加载顺序是正确的非常重要。如果加载顺序错误，可能会导致某些模块在使用时还未被加载，从而出现错误。解决加载顺序错误的方法包括：
   - 明确定义模块之间的依赖关系，确保先加载依赖的模块，再加载依赖它们的模块。
   - 使用模块打包工具（如 Webpack、Rollup 等）来管理模块之间的依赖关系和加载顺序，确保打包后的文件能正确加载所有模块。
3. **使用命名导出和默认导出**： 在模块间引用时，可以使用命名导出和默认导出来更清晰地定义模块之间的关系。通过明确导出和导入需要的函数、变量等，可以减少不必要的引用问题。
4. **使用事件订阅/发布模式**： 如果存在模块之间需要通信的情况，可以考虑使用事件订阅/发布模式（Event Emitter），模块之间通过事件进行通信，避免直接引用对方。

总的来说，避免 JavaScript 文件相互引用时的常见问题，需要注意模块之间的依赖关系、加载顺序以及合理设计模块之间的通信机制。通过合理的代码组织和模块化设计，可以有效减少相互引用带来的问题，并确保代码的可维护性和可扩展性。



### 2.5 CommonJS 和 ES Module 的区别





### 2.6 setTimeout 和 setInterval 的区别





### 2.7 for...in 和 for...of 的区别





### 2.8 深拷贝和浅拷贝的区别





### 2.9 Object.prototype.toString.call





### 2.10 JavaScript 数值精度问题

在 JavaScript中，由于浮点数的表示方式（基于IEEE 754 标准），我们有时会遇到数值精度问题。这些问题主要源于**二进制浮点数的表示限制，导致无法精确表示所有的十进制小数**。

以下是一些解决 JavaScript 数值精度问题的方法：

1. **toFixed() 方法**：
   - 当你需要将浮点数转换为字符串并保留一定的小数位数时，可以使用 `toFixed()` 方法。但请注意，`toFixed()` 返回的是一个字符串，而不是一个数字。
2. **Math.round(), Math.floor(), Math.ceil()**：
   - 这些函数可以帮助你四舍五入、向下取整或向上取整到最接近的整数。
3. **使用第三方库**：
   - 有些第三方库，如 `decimal.js` 或 `bignumber.js`，提供了高精度的十进制数运算。这些库可以处理比JavaScript内置Number类型更大或更精确的数值。

在处理金融或需要高精度计算的场景时，使用第三方库（如 `decimal.js` 或 `bignumber.js`）通常是一个好主意，因为它们提供了比JavaScript内置Number类型更高的精度和可靠性。



### 2.11 事件 level0、level1

在HTML中，`level0`和`level1`并不是标准的事件处理术语。然而，我们可以讨论HTML中的事件处理机制，以及如何在不同层级（如元素层级）上添加事件。

1. 基本的 HTML 事件处理（类似于 “level0”）

   在HTML中，你可以直接在元素标签内使用`on<event>`属性来添加事件监听器。例如：

   ```html
   <button onclick="alert('Button clicked!')">Click Me</button>
   ```

2. 使用 JavaScript 添加事件监听器（类似于 “level1” 或更高级别）

   为了更灵活和可维护的代码，通常建议使用JavaScript来添加事件监听器。这可以通过`addEventListener`方法来实现。

   ```html
   <!DOCTYPE html>  
   <html lang="en">  
   <head>  
     <meta charset="UTF-8">  
     <meta name="viewport" content="width=device-width, initial-scale=1.0">  
     <title>Event Handling Example</title>  
   </head>  
   <body>  
     <button id="myButton">Click Me</button>  
     
     <script>  
       // 获取按钮元素  
       var button = document.getElementById('myButton');  
       // 添加点击事件监听器  
       button.addEventListener('click', function() {  
         alert('Button clicked via addEventListener!');  
       });  
     </script>  
   </body>  
   </html>
   ```

3. 层级概念

   在 HTML 和 JavaScript 中，事件可以在不同的层级上被捕获和处理。这通常涉及事件冒泡（event bubbling）和事件捕获（event capturing）的概念。

   - **事件冒泡**：事件从触发它的最内层元素（目标元素）开始，然后向外层元素传播，直到到达文档的根元素（通常是`document`对象）。
   - **事件捕获**：与事件冒泡相反，事件从文档的根元素开始，然后向目标元素传播，直到到达目标元素本身。

   在大多数情况下，你会使用事件冒泡，因为它更符合直觉，并且更容易管理。但是，在某些情况下，你可能需要使用事件捕获来阻止事件冒泡或实现特定的交互逻辑。

4. level0、level1 对比

   虽然 “level0” 和 “level1” 不是 HTML 或 JavaScript 中的标准术语，但你可以理解它们为不同级别的事件处理方式。基本的 HTML 事件处理（如`onclick` 属性）可以看作是较低级别的方式，而使用 JavaScript 的 `addEventListener` 方法则提供了更高级别、更灵活的事件处理机制。

5. 场景

   在HTML和JavaScript中，如果一个元素同时被添加了两种事件处理器（例如，通过HTML属性如`onclick`和通过JavaScript的`addEventListener`方法），那么事件的触发顺序通常遵循以下规则：

   - **HTML属性事件处理器（如`onclick`）**：这些事件处理器是在元素标记中直接定义的，它们通常会在JavaScript添加的事件监听器之前被触发。这是因为这些事件处理器是在元素解析和构建DOM时就已经存在的，而JavaScript添加的事件监听器则是在页面加载和JavaScript执行时才被添加到DOM中的。
   - **JavaScript添加的事件监听器（`addEventListener`）**：这些事件监听器是通过JavaScript代码动态添加到元素上的。它们会在HTML属性事件处理器之后被触发。这是因为`addEventListener`方法允许更精细的控制，包括指定事件是否在捕获阶段触发，以及添加多个事件监听器而不会相互覆盖。

   然而，需要注意的是，这种触发顺序并不是绝对的，因为它可能受到多种因素的影响，包括浏览器的实现细节、JavaScript代码的执行时机和顺序等。在某些情况下，如果JavaScript代码在页面加载的非常早期就执行了（例如，在`<head>`标签中或通过`DOMContentLoaded`事件），并且添加了事件监听器，那么这些监听器可能会在页面完全解析和构建DOM之前就已经存在，从而可能改变事件的触发顺序。

   此外，如果使用了事件委托（即在父元素上监听事件，然后根据事件的目标元素来执行相应的操作），那么事件的触发顺序也会受到影响，因为事件是在父元素上捕获的，然后根据需要冒泡到目标元素或停止传播。

   总的来说，为了确保事件的正确处理和触发顺序，建议避免在同一个元素上同时使用HTML属性事件处理器和JavaScript添加的事件监听器。相反，应该选择其中一种方法，并保持一致的事件处理策略。这样可以减少潜在的冲突和不确定性，使代码更加清晰和可维护。



